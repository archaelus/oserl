
	OSERL overview page

@author Enrique Marcote Peña <mpquique_at_users.sourceforge.net> [http://oserl.sourceforge.net/]
@copyright 2003 - 2005 Enrique Marcote Peña
@version 1.2

@doc OSERL is an Erlang implementation of the Short Message Peer to Peer 
Protocol version 5.0.

<p>As a guideline, some comments include references to the specific section
numbers on [SMPP 5.0].</p>


<h2><a name="contents">Contents</a></h2>
<ol>
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#install">Install OSERL</a></li>
  <li><a href="#overview">SMPP protocol implementation overview</a></li>
  <li><a href="#behaviours">SMPP Behaviours</a></li>
  <li><a href="#howto">Developing SMS based applications with OSERL</a>
    <ol>
      <li><a href="#howto_esme">How to implement an ESME</a>
        <ol>
          <li><a href="#esme_skel">ESME skeleton</a></li>
          <li><a href="#submit">Submit SM sample (java vs. erlang)</a></li>
          <li><a href="#echo">Sample echo ESME</a></li>
        </ol> 
      </li>
      <li><a href="#howto_smsc">How to implement a SMSC</a></li>
        <ol>
          <li><a href="#smsc_skel">SMSC skeleton</a></li>
          <li><a href="#test">Test SMSC</a></li>
        </ol> 
      <li><a href="#tune">Fine tune OSERL's SMPP implementation</a>
        <ol>
          <li><a href="#smpp_pdu">smpp_pdu.hrl</a></li>
          <li><a href="#smpp_param">smpp_param.hrl</a></li>
          <li><a href="#smpp_base">smpp_base.hrl</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#storage">PDU data storage</a></li>
  <li><a href="#translation">Translating the SMPP specification</a></li>
  <li><a href="#base">Base Syntax</a></li>
  <li><a href="#basemacros">Base Syntax Macros</a></li>
  <li><a href="#param">Param Syntax</a></li>
  <li><a href="#parammacros">Param Syntax Macros</a></li>
  <li><a href="#pdu">PDU Syntax</a></li>
  <li><a href="#pdumacros">PDU Syntax Macros</a></li>
  <li><a href="#pics">PICS Proforma</a></li>
  <li><a href="#changes">Changes</a></li>
  <li><a href="#todo">TODO</a></li>
  <li><a href="#contributors">Contributors</a></li>
  <li><a href="#thanks">Special Thanks</a></li>
  <li><a href="#references">References</a></li>
</ol>


<h2><a name="intro">Introduction</a></h2>

<p>Short Message Peer to Peer (SMPP) protocol [SMPP 5.0] is an open, 
industry standard designed to provide a flexible data communications interface 
for the transfer of short message data between External Short Message Entities 
(ESME), Routing Entities (RE) and Short Message Service Centers (SMSC).</p>

<p>A great amount of the effort required for the development of any of the 
above mention entities is generally spent on a partial implementation of the 
SMPP protocol.  It is rare to find an implementation that covers every aspect 
of the SMPP protocol as OSERL does.</p>

<p>OSERL (open SMPP erlang library) comprises the <i>entire specification</i> 
of the recently released SMPP version 5.0 (February 20th, 2003).  Moreover, 
every forward and backward compatibility guidelines were adopted at the design 
stage, what makes the resulting library easy to maintain and update to any
future or previous version of the protocol.</p>

<h2><a name="install">Install OSERL</a></h2>

You need to have <a href="http://www.erlang.org/">erlang</a> installed before 
you attempt to use OSERL.  

<p>Erlang is a concurrent functional programming language designed for 
programming large industrial real-time systems. Erlang is dynamically typed 
and has a pattern matching syntax. Functions are defined using recursion 
equations. Erlang provides explicit concurrency, has asynchronous message 
passing and is relatively free from side effects.</p>

<p>Distributed Erlang programs can run transparently on cross-platform 
multi-vendor systems. The language has primitives for detecting run-time errors
and for dynamic code replacement (i.e. changes to code can be made in a running
real-time system, without stopping system).</p>

<p>Install common_lib package:</p>

<pre>
  tar -zxvf common_lib-1.0.tar.gz
  cd common_lib-1.0
  make
</pre>

<p>Install oserl package:
</p>

<pre>
  tar -zxvf oserl-1.1.tar.gz
  cd oserl-1.1
  make
</pre>

<p>Put the ebin directory of both packages in your code path.  You may add 
these lines to your <tt>~/.erlang</tt></p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
code:add_path("&lt;path-to-common_lib&gt;/ebin").
code:add_path("&lt;path-to-oserl&gt;/ebin").
</pre>
    </td>
  </tr>
</table>

<p>To compile an erlang program using oserl, don't forget to add a reference to
the include directory:</p>

<pre>
   -I &lt;path-to-oserl&gt;/include -pz &lt;path-to-oserl&gt;/ebin
</pre>


<h2><a name="overview">SMPP protocol implementation overview</a></h2>

<p>The SMPP protocol defines a set of operations, each one taking the form of
a request and response PDU (Protocol Data Unit).</p>

<p>The first challenge to face on the implementation was to develop packing 
and unpacking functions for the command PDUs.  The approach was to translate 
the entire SMPP protocol specification to erlang terms using the syntax 
notation described next.  Then, we only needed to create the encoding and 
decoding functions for the primitive types used on our notation, and the whole 
problem of the SMPP PDU packing/unpacking was solved.</p>

<p>Notice that whenever a new version of the SMPP protocol gets released, 
we'll just need to update our "static" translation of the protocol to get 
support for new parameters and PDUs.  Packing and unpacking functions
won't need to be modified.</p>

<p>Besides the PDU format, encoding (decoding) mechanisms and associated error 
codes, the SMPP protocol specification defines how a well behaved SMPP based 
application should be implemented.  Even the behaviour of every ESME (RE or MC)
is predefined by the protocol specification in many senses, nowadays every 
developer must program these dynamic aspects of the protocol on its own.  
OSERL provides a <a href="#behaviours">generic ESME</a>  implementation that 
transparently handles just about every feature of the SMPP protocol that 
leaves room for automation, and there are many of them, as we will see 
<a href="#behaviours">later on</a>.</p>

<p>SMPP version 5.0 declares 31 PDUs for 19 operations.  All SMPP PDUs 
comprise of organized set of parameters.  Those parameters are defined by 
means of a primitive type:  <i>Integer</i>, <i>C-Octet String</i> and 
<i>Octet String</i>.  As well as the primitive type, every parameter has a 
<i>name</i>, a <i>domain</i> (set of permitted values of the primitive 
type) and optionally an associated <i>error code</i>.  Furthermore, there is a 
kind of parameters called TLVs (Tagged Length Value), whose definition also 
involves a <i>tag</i> (identifier), a set of <i>reserved values</i> (of the 
primitive type) and sometimes, a <i>default value</i>.</p>

<p>We divided the syntax notation into three layers; <a href="#base">base 
syntax</a>, <a href="#param">param syntax</a> and <a href="#pdu">PDU syntax</a>
layer.  The first one is used to define the erlang data structures for the 
representation of the SMPP primitive types, domains and reserved values.  The 
parameter syntax provides an erlang notation to complete the field  definitions
(we'll use field and parameter interchangeable), adding to the primitive 
types of the underlying layer: parameter names, error codes and default values.
On top of the parameter syntax, a PDU syntax was built, this upper layer 
defines the structure for a PDU descriptor.</p>

<p>Each syntax layer has its own encoding and decoding functions.  The PDU 
packing function relies on the parameter encoder to translate to binary format 
every individual field of a PDU.  In the same way, the parameter syntax layer 
doesn't know how encode a primitive value and again, must rely on the base 
syntax encoder to do the work.  The same process applies  for the unpacking 
mechanism.</p>

<table width="100%" border="0" cellpadding="0">
  <tr> 
    <td width="70%" valign="top" align="center">
      <table width="100%" border="1" cellpadding="2">
        <tr> 
          <th colspan="2" valign="middle" align="center">operation</th>
        </tr>
        <tr> 
          <th valign="middle" align="center">PDU datatypes</th>
          <th valign="middle" align="center">PDU pack/unpack</th>
        </tr>
        <tr> 
          <th valign="middle" align="center">Param datatypes</th>
          <th valign="middle" align="center">Param encoding/decoding</th>
        </tr>
        <tr> 
          <th valign="middle" align="center">Base datatypes</th>
          <th valign="middle" align="center">Base encoding/decoding</th>
        </tr>
      </table>
    </td>
    <td width="30%" valign="top" align="center">
      <table width="100%" border="0" cellpadding="3">
        <tr> 
          <th align="left">&#160;</th>
        </tr>
        <tr> 
          <th align="left">PDU syntax</th>
        </tr>
        <tr> 
          <th align="left">Param syntax</th>
        </tr>
        <tr> 
          <th align="left">Base syntax</th>
        </tr>
      </table>
    </td>
  </tr>
</table>

<p>On this table we find the SMPP <a href="operation.html">operation</a> 
module on top of the PDU syntax.  This module hides the type descriptors of 
the SMPP specification to higher layers.</p>


<h2><a name="behaviours">SMPP Behaviours</a></h2>

<p>Generic ESME (External Short Message Entity) and SMSC (Short Message Service
Center) behaviours are implemented in OSERL.  Behaviours are formalizations of 
"design patters" which can be used to program certain common problems, an ESME 
or SMSC in this particular case.  The generic ESME behaviour was built on top 
of a generic ESME session behaviour, while generic SMSC behaviour has 
an underlying generic SMSC session behaviour.  Both (ESME and SMSC behaviours) 
are a sort of an extended <i>gen_server</i> behaviour.</p>

<img src="img/behaviours.png" 
     alt="behaviours" 
     border="0" 
     width="601" 
     height="132"/>

<p>The schema depicted on the previous figure shows how the ESME/SMSC 
behaviours act as the callback modules for their corresponding session 
behaviours.</p>

<p>The session receives binary data from a TCP/IP connection and unpacks 
SMPP PDUs therein included.  Some operation PDUs are automatically responded 
and managed by session behaviours but others, like an <i>outbind</i> or 
<i>submit_sm</i> PDU, must be forwarded to the upper ESME/SMSC behaviour to 
let it decide what to do.</p>

<p>SMS Developers don't need to care about sessions or connections, they will 
just need to implement the logic of their applications using the set of 
callbacks exported by the ESME/SMSC behaviours.</p> 

<p>Leaving a callback unimplemented <b>crashes</b> the entire 
ESME/SMSC server whenever that particular function gets called.</p>  

<p><i>Every callback is guaranteed to be correct, never a malformed or 
unexpected PDU could trigger a callback.</i></p>

<p>Due to these behaviours, OSERL handles transparently many aspects of the 
SMPP protocol, saving lots of work to developers by</p>

<ul>
  <li>Automatically handling PDU sequencing. Assigns monotonically 
    increasing sequence numbers and matches requests with their corresponding 
    responses in an asynchronous manner.
  </li>
  <li>OSERL handles automatically all timers defined by the SMPP protocol 
    specification version 5.0: session init timer, enquire link timer, 
    inactivity timer and response timer.  On a timer expiration, the action 
    recommended on the protocol specification is triggered.
  </li>
  <li>Handles every operation failure, including when the PDU is unrecognized 
	or malformed, invalid field length, PDU data is unexpected and deemed 
	invalid, and the PDU is not allowed in the current state.

 	<p>Upon failure the appropriate response is automatically issued.  Even 
	errors associated to individual parameters of the PDUs are detected, and
	reported using the corresponding error code.</p>

    <p>Every error code in the protocol specification was implemented.</p>
  </li>
  <li>Detects connection failures and provides automatic recovery mechanisms,
	restoring dropped sessions.
  </li>
  <li>Controls congestion using the <tt>congestion_state</tt> field.</li>
  <li>Every forward and backwards compatibility guidelines were adopted.</li>
  <li>Supports every operation and every field of the SMPP protocol 
	version 5.0.
  </li>
</ul>


<h2><a name="howto">Developing SMS based applications with OSERL</a></h2>

This sections shows how to implement SMS based applications with the
Open SMPP Erlang Library. 

<p>Even if you don't have any prior experience with it, I strongly recommend 
you considering erlang as the programming language for the development of 
your ESME/SMSC or RE.</p>

<p>If you are reluctant to experience with a new (better ;-) development 
environment, you may want to consider using OSERL anyway.  Erlang has 
<a href="http://www.erlang.org/doc/r9c/doc/tutorial/part_frame.html">mechanisms
to talk to other languages</a> such us C or java.</p>

<p>Examples below only apply to erlang development.</p>


<h3><a name="howto_esme">How to implement an ESME</a></h3>

This is a long read.  Hope the examples I've include here complement the rest 
of the documentation (I realize there was a lack of code samples on it).

<p>I assume you have OSERL installed and you are already familiar with 
<a href="http://www.erlang.org/doc/r9c/doc/design_principles/part_frame.html">
OTP behaviors</a>.  Should you encounter any problems installing OSERL, please 
let me know.</p>

<p>To implement an ESME I recommend using the <a href="gen_esme.html">gen_esme
</a> behavior.  This is a custom behavior (provided within OSERL), which 
automatically handles many of the cumbersome details associated to an ESME 
implementation.  If you use this behavior you won't need to care about SMPP 
timers, PDU sequencing, link enquires, PDU encoding/decoding, error checking, 
error responses and so forth.  The <a href="gen_esme.html">gen_esme 
behavior</a> takes care of these things for you.</p>

<p>Let us see how the whole thing works by example.  First, we'll compare
erlang and java implementations by the <a href="examples/submit_esme.erl">
submit_esme.erl</a> example.  Next we'll find out how to implement a simple
echo ESME.</p>


<h4><a name="esme_skel">ESME skeleton</a></h4>

<p>OSERL ships an ESME skeleton which might be a good starting point for your
ESME development.</p>

<p>Find the <a href="esme_skel.html">esme_skel</a> module under
<a href="examples/esme_skel.erl">doc/examples/esme_skel.erl</a>.</p>


<h4><a name="submit">Submit SM sample (java vs. erlang)</a></h4>

<p>If you are a SMPP developer, you will be familiar with java or C SMPP APIs, 
and wondering how does an equivalent erlang code to a given java example, 
looks like.  Such a comparison is shown in <a href="examples/submit_esme.erl">
doc/examples/submit_esme.erl</a>, where a <i>submit_sm</i> java code is
directly translated into erlang, using OSERL.</p>

<p>The original java sample had too many I/O instructions, since these kind of
instructions are pretty much the same in any language, you'll find both
implementations very similar.  I believe this <i>submit_sm</i> example 
doesn't show the real strength of a SMPP erlang implementation.  To find out 
the advantages of OSERL, I encourage you to implement the <a href="#echo">echo 
ESME</a> example in a language such us java, and compare the result with the 
erlang implementations given below (I think you'll find erlang implementation 
much more readable and compact).</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <th width="50%" align="center">java submit_sm</th>
    <th width="50%" align="center">erlang submit_sm</th>
  </tr>
  <tr>
    <td width="50%" valign="top">
<pre>
public String  submit(String mobileNumber, String userMessage) {
    SubmitSM request = new SubmitSM();
    SubmitSMResp response;
  
    // input values
    serviceType = getParam("Service type", serviceType);
    sourceAddress = getAddress("Source",sourceAddress);
    destAddress = getAddress("Destination",new Address(mobileNumber));
    replaceIfPresentFlag = getParam("Replace if present flag", 
                                     replaceIfPresentFlag);
    shortMessage = userMessage;
    scheduleDeliveryTime = getParam("Schedule delivery time", 
                                    scheduleDeliveryTime);
    validityPeriod = getParam("Validity period", validityPeriod);
    esmClass = getParam("Esm class", esmClass);
    protocolId = 0;
    priorityFlag = getParam("Priority flag", priorityFlag);
    registeredDelivery = getParam("Registered delivery", 
                                   registeredDelivery);
    dataCoding = 0x10; // For Flash Message
    smDefaultMsgId = getParam("Sm default msg id", smDefaultMsgId);

    // set values
    request.setServiceType(serviceType);
    request.setSourceAddr(sourceAddress);
    request.setDestAddr(destAddress);
    request.setReplaceIfPresentFlag(replaceIfPresentFlag);
    request.setShortMessage(shortMessage);
    request.setScheduleDeliveryTime(scheduleDeliveryTime);
    request.setValidityPeriod(validityPeriod);
    request.setEsmClass(esmClass);
    request.setProtocolId(protocolId);
    request.setPriorityFlag(priorityFlag);
    request.setRegisteredDelivery(registeredDelivery);
    request.setDataCoding(dataCoding);
    request.setSmDefaultMsgId(smDefaultMsgId);

    // send the request
    int count = 1;
    System.out.println();
    count = getParam("How many times to submit this message (load test)",
                     count);
    for (int i = 0; i&lt;count; i++) {
        request.assignSequenceNumber(true);
        //System.out.print("#"+i+"  ");
        System.out.println("Submit request " + request.debugString());
        if (asynchronous) {
            //session.submit(request);  
            response = session.submit(request);
            messageId = response.getMessageId();
            //System.out.println();
            return messageId;
        } else {
            response = session.submit(request);                    
            messageId = response.getMessageId();
            System.out.println("Submit response " + 
                               response.debugString() + 
                               " MESSAGE ID : " + 
                               messageId);
            return messageId;
        }
    }   
    return messageId;            
}
</pre>
    </td>
    <td width="50%" valign="top">
<pre>
submit_sm(MobileNumber, UserMessage) ->



    % input values
    ServiceType = read_string("Service type> "),
    SourceAddress = read_string("Source> "),

    ReplaceIfPresentFlag = read_decimal("Replace if present flag> "),


    ScheduleDeliveryTime = read_string("Schedule delivery time> "),

    ValidityPeriod = read_string("Validity period> "),
    EsmClass = read_decimal("Esm class> "),
    ProtocolId = 0,
    PriorityFlag = read_decimal("Priority flag> "),
    RegisteredDelivery = read_decimal("Registered delivery> "),

    DataCoding = 2#10,  % For Flash Message
    SmDefaultMsgId = read_decimal("Sm default msg id> "),

    % set values (create the ParamList)
    ParamList = [{service_type, ServiceType},
                 {source_addr, SourceAddress},
                 {destination_addr, MobileNumber},
                 {replace_if_present_flag, ReplaceIfPresentFlag},
                 {short_message, UserMessage},
                 {schedule_delivery_time, ScheduleDeliveryTime},
                 {validity_period, ValidityPeriod},
                 {esm_class, EsmClass},
                 {protocol_id, ProtocolId},
                 {priority_flag, PriorityFlag},
                 {registered_delivery, RegisteredDelivery},
                 {data_coding, DataCoding},
                 {sm_default_msg_id, SmDefaultMsgId}],

    % send the request
    case read_decimal("How many times to submit this message (load test)") of
        Count when integer(Count) -> submit_sm_async_iter(ParamList, Count);
        _Error                    -> submit_sm_async_iter(ParamList, 1)
    end.


submit_sm_async_iter(ParamList, 0) -> 
    ok;
submit_sm_async_iter(ParamList, Count) ->
    spawn(fun() -> submit_sm(ParamList) end),
    submit_sm_async_iter(ParamList, Count - 1).


submit_sm(ParamList) -> 
    case gen_esme:submit_sm(?ESME_NAME, ParamList) of
        {ok, Response} -> 
            % See how to get a parameter value
            MessageId = operation:get_param(message_id, Response),
            io:format("Message ID: ~p~n", [MessageId]);
        {error, Error} ->
            io:format("Submit operation failed with ~p~n", [Error])
    end.
</pre>
    </td>
  </tr>
</table>

<p><a href="submit_esme.html">submit_esme</a> is not just an erlang 
<i>submit_sm</i> function, but a complete ESME implementation.  This ESME
binds as a transmitter, behaves asynchronously, controls congestion and 
connection failures, and transparently handles SMPP timers and other
aspects defined in the SMPP protocol.</p>

<p>Get into doc/examples directory and compile the <a href="submit_esme.html">
submit_esme</a> example by</p>

<pre>
    $ erlc -W -I ../../include -pz ../../ebin submit_esme.erl
</pre>

<p>Now, open an erlang shell and test it:</p>

<pre>
    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; executing user profile in HOME/.erlang
    .erlang rc finished
</pre>

<p>Assuming you've untared the <i>common_lib</i> and <i>oserl</i> in the same 
subdirectory.</p>

<pre>
    1&gt; code:add_path("../../../common_lib/ebin").
    true
    2&gt; code:add_path("../../ebin").
    true
</pre>

<p>and finally do</p>

<pre>
    3&gt; submit_esme:start().
    {ok,&lt;0.21.0&gt;}
    4&gt;  submit_esme:submit_sm("123456789", "hello there").
    "Service type> "CMT
    "Source> "1959
    "Replace if present flag> "0
    "Schedule delivery time> "040207105523000+
    "Validity period> "040208105523000+
    "Esm class> "0
    "Priority flag> "0
    "Registered delivery> "0
    "Sm default msg id> "0
    "How many times to submit this message (load test)"5
    ok
    Message ID: "34800629"
    Message ID: "24512469"
    Message ID: "49646623"
    Message ID: "34236909"
    Message ID: "64973652"
    4&gt; submit_esme:stop().
    ok
</pre>

<p>To test your applications you may use the SMPPSim SMSC simulator by Martin 
Woolley.  You can download SMPPSim from 
<a href="http://www.mobilelandscape.co.uk/">
http://www.mobilelandscape.co.uk</a>.</p>

<p>Since version 1.1 OSERL includes a minimal <a href="#test">test SMSC</a>. 
You can use this SMSC for your tests also, please read below for more details 
on this <a href="#test">test SMSC</a>.</p>


<h4><a name="echo">Sample echo ESME</a></h4>

<a href="echo_esme.html">echo_esme</a> offers a very simple (and useless) 
service to subscribers.  Whenever a client sends a Short Message to this 
service, the ESME responds sending back the exact same Short Message.

<p>You may find this example under <a href="examples/echo_esme.erl">
doc/examples/echo_esme.erl</a>.</p>

<p>Get into doc/examples directory compile and test this new example:</p>

<pre>
    $ erlc -W -I ../../include -pz ../../ebin echo_esme.erl

    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; executing user profile in HOME/.erlang
    .erlang rc finished
    1&gt; code:add_path("../../../common_lib/ebin").
    true
    2&gt; code:add_path("../../ebin").
    true
    3&gt; echo_esme:start().
    Bound as transmitter to "SMPPSim"
    {ok,&lt;0.41.0&gt;}
    Bound as receiver to "SMPPSim"
</pre>

<p>In the <a href="#test">test SMSC</a> section below, this echo example is
tested using the <a href="examples/test_smsc.erl">test_smsc.erl</a> shipped
with OSERL.</p>

<p>You may rather want to test this example using the SMSC simulator by Martin 
Woolley, if so, you can use <a href="examples/send_oserl.html">this HTML 
form</a> to try sending short messages to your test ESMEs.</p>

<p>Notice the address of the echo service is <i>1948</i> by default.  If you 
decide to start the ESME in another address, you will need to change the 
destination address.  Don't forget to point the SMSC IP address, in the HTML 
form, to where your SMPPSim SMSC simulator resides.</p>

<p>Type the message "hello" in the HTML form and click the 
button &lt;send&gt;.  You won't get the echo response back in your browser 
phone, or whatever it looks like :-).  SMPPSim SMSC simulator doesn't support 
that, this tool just listens on a HTTP port, but cannot send SM responses back.
Anyway, you should see the following message in your browser:</p>

<pre>
    DELIVER_SM invoked OK
</pre>

<p>This means the message was successfully forwarded to your ESME.  We can 
confirm that looking on the erlang shell, where the following message should be
displayed:</p>

<pre>
    Echoing SM: {short_message,"hello"}
</pre>

<p>Let's give it another try (send another message with text "bye" and stop
the ESME).</p>

<pre>
    Echoing SM: {short_message,"bye"}
    4&gt; echo_esme:stop().
    Unbound as receiver.
    Unbound as transmitter.
    ok
</pre>

<p>During this session, the log of the SMSC simulator shows something like:</p>

<pre>
2004.02.07 11:25:43 668 INFO    CH8: BIND_RECEIVER:
2004.02.07 11:25:43 668 INFO    Hex dump (39) bytes:
2004.02.07 11:25:43 668 INFO    00000027:00000001:00000000:00000001:
2004.02.07 11:25:43 668 INFO    62616E61:6E610073:65637265:74000050:
2004.02.07 11:25:43 669 INFO    01013139:343800
2004.02.07 11:25:43 669 INFO
2004.02.07 11:25:43 670 INFO    SMPPReceiver: setting address range to 1948
2004.02.07 11:25:43 670 INFO    CH8: BIND_RECEIVER_RESP:
2004.02.07 11:25:43 671 INFO    Hex dump (24) bytes:
2004.02.07 11:25:43 671 INFO    00000018:80000001:00000000:00000001:
2004.02.07 11:25:43 671 INFO    534D5050:53696D00:
2004.02.07 11:25:43 671 INFO
2004.02.07 11:25:43 671 INFO    1 receivers connected and bound
2004.02.07 11:25:43 674 INFO    ConnectionHandler CH9 accepted a connection
2004.02.07 11:25:43 677 INFO    CH9: BIND_TRANSMITTER:
2004.02.07 11:25:43 677 INFO    Hex dump (39) bytes:
2004.02.07 11:25:43 677 INFO    00000027:00000002:00000000:00000001:
2004.02.07 11:25:43 677 INFO    62616E61:6E610073:65637265:74000050:
2004.02.07 11:25:43 677 INFO    01013139:343800
2004.02.07 11:25:43 677 INFO
2004.02.07 11:25:43 678 INFO    CH9: BIND_TRANSMITTER_RESP:
2004.02.07 11:25:43 678 INFO    Hex dump (24) bytes:
2004.02.07 11:25:43 678 INFO    00000018:80000002:00000000:00000001:
2004.02.07 11:25:43 678 INFO    534D5050:53696D00:
2004.02.07 11:25:43 678 INFO
2004.02.07 11:25:49 022 INFO    HC0 accepted connection
2004.02.07 11:25:49 023 INFO    HC0: DELIVER_SM
2004.02.07 11:25:49 024 INFO    DELIVER_SM:
2004.02.07 11:25:49 024 INFO    Hex dump (51) bytes:
2004.02.07 11:25:49 024 INFO    00000033:00000005:00000000:00000006:
2004.02.07 11:25:49 024 INFO    00000031:32333435:36373839:00000031:
2004.02.07 11:25:49 024 INFO    39343800:00000000:00000000:00056865:
2004.02.07 11:25:49 024 INFO    6C6C6F
2004.02.07 11:25:49 025 INFO
2004.02.07 11:25:49 025 INFO    HTTPController HC0 waiting for connection
2004.02.07 11:25:49 030 INFO    CH8: DELIVER_SM_RESP:
2004.02.07 11:25:49 030 INFO    Hex dump (27) bytes:
2004.02.07 11:25:49 030 INFO    0000001B:80000005:00000000:00000006:
2004.02.07 11:25:49 030 INFO    00001D00:01000428:000100
2004.02.07 11:25:49 030 INFO
2004.02.07 11:25:49 035 INFO    CH9: SUBMIT_SM:
2004.02.07 11:25:49 035 INFO    Hex dump (117) bytes:
2004.02.07 11:25:49 035 INFO    00000075:00000004:00000000:00000002:
2004.02.07 11:25:49 035 INFO    00010131:39343800:00003132:33343536:
2004.02.07 11:25:49 035 INFO    37383900:00000000:00000003:00056865:
2004.02.07 11:25:49 035 INFO    6C6C6F00:05000100:00070001:01000600:
2004.02.07 11:25:49 035 INFO    01010008:00020000:04240000:00190001:
2004.02.07 11:25:49 035 INFO    00020F00:0101020E:00010104:21000101:
2004.02.07 11:25:49 035 INFO    000D0001:00000F00:0101000E:00010100:
2004.02.07 11:25:49 035 INFO    10000200:00
2004.02.07 11:25:49 035 INFO
2004.02.07 11:25:49 036 INFO    CH9:SUBMIT_SM_RESP:
2004.02.07 11:25:49 036 INFO    Hex dump (25) bytes:
2004.02.07 11:25:49 036 INFO    00000019:80000004:00000000:00000002:
2004.02.07 11:25:49 037 INFO    37353333:33373232:00
2004.02.07 11:25:49 037 INFO
2004.02.07 11:25:56 460 INFO    HC0 accepted connection
2004.02.07 11:25:56 461 INFO    HC0: DELIVER_SM
2004.02.07 11:25:56 463 INFO    DELIVER_SM:
2004.02.07 11:25:56 464 INFO    Hex dump (49) bytes:
2004.02.07 11:25:56 464 INFO    00000031:00000005:00000000:00000007:
2004.02.07 11:25:56 464 INFO    00000031:32333435:36373839:00000031:
2004.02.07 11:25:56 464 INFO    39343800:00000000:00000000:00036279:
2004.02.07 11:25:56 464 INFO    65
2004.02.07 11:25:56 464 INFO
2004.02.07 11:25:56 464 INFO    HTTPController HC0 waiting for connection
2004.02.07 11:25:56 468 INFO    CH8: DELIVER_SM_RESP:
2004.02.07 11:25:56 468 INFO    Hex dump (27) bytes:
2004.02.07 11:25:56 468 INFO    0000001B:80000005:00000000:00000007:
2004.02.07 11:25:56 468 INFO    00001D00:01000428:000100
2004.02.07 11:25:56 468 INFO
2004.02.07 11:25:56 469 INFO    CH9: SUBMIT_SM:
2004.02.07 11:25:56 469 INFO    Hex dump (115) bytes:
2004.02.07 11:25:56 469 INFO    00000073:00000004:00000000:00000003:
2004.02.07 11:25:56 469 INFO    00010131:39343800:00003132:33343536:
2004.02.07 11:25:56 469 INFO    37383900:00000000:00000003:00036279:
2004.02.07 11:25:56 469 INFO    65000500:01000007:00010100:06000101:
2004.02.07 11:25:56 470 INFO    00080002:00000424:00000019:00010002:
2004.02.07 11:25:56 470 INFO    0F000101:020E0001:01042100:0101000D:
2004.02.07 11:25:56 470 INFO    00010000:0F000101:000E0001:01001000:
2004.02.07 11:25:56 470 INFO    020000
2004.02.07 11:25:56 470 INFO
2004.02.07 11:25:56 471 INFO    CH9:SUBMIT_SM_RESP:
2004.02.07 11:25:56 471 INFO    Hex dump (25) bytes:
2004.02.07 11:25:56 471 INFO    00000019:80000004:00000000:00000003:
2004.02.07 11:25:56 471 INFO    36363137:36343538:00
2004.02.07 11:25:56 471 INFO
</pre>

<p>One comment here. Notice there is one minute of inactivity since last 
submit, while in the demonstration above, I've intentionally waited 1 minute 
before stoping the ESME, see how the <a href="gen_esme.html">gen_esme</a> 
behavior transparently handles inactivity timers (look at the enquire links in 
both sessions).</p>
 
<pre>
2004.02.07 11:26:56 916 INFO    CH8: ENQUIRE_LINK:
2004.02.07 11:26:56 916 INFO    Hex dump (16) bytes:
2004.02.07 11:26:56 916 INFO    00000010:00000015:00000000:00000008:
2004.02.07 11:26:56 916 INFO
2004.02.07 11:26:56 917 INFO
2004.02.07 11:26:56 917 INFO    CH8: ENQUIRE_LINK_RESP:
2004.02.07 11:26:56 917 INFO    Hex dump (16) bytes:
2004.02.07 11:26:56 917 INFO    00000010:80000015:00000000:00000008:
2004.02.07 11:26:56 917 INFO
2004.02.07 11:26:56 917 INFO
2004.02.07 11:26:56 917 INFO    CH9: ENQUIRE_LINK:
2004.02.07 11:26:56 917 INFO    Hex dump (16) bytes:
2004.02.07 11:26:56 917 INFO    00000010:00000015:00000000:00000004:
2004.02.07 11:26:56 917 INFO
2004.02.07 11:26:56 917 INFO
2004.02.07 11:26:56 918 INFO    CH9: ENQUIRE_LINK_RESP:
2004.02.07 11:26:56 918 INFO    Hex dump (16) bytes:
2004.02.07 11:26:56 918 INFO    00000010:80000015:00000000:00000004:
2004.02.07 11:26:56 918 INFO
2004.02.07 11:27:07 273 INFO    CH8: UNBIND
2004.02.07 11:27:07 273 INFO    Hex dump (16) bytes:
2004.02.07 11:27:07 273 INFO    00000010:00000006:00000000:00000009:
2004.02.07 11:27:07 273 INFO
2004.02.07 11:27:07 273 INFO
2004.02.07 11:27:07 275 INFO    0 receivers connected and bound
2004.02.07 11:27:07 277 INFO    CH8: UNBIND_RESP
2004.02.07 11:27:07 277 INFO    Hex dump (16) bytes:
2004.02.07 11:27:07 277 INFO    00000010:80000006:00000000:00000009:
2004.02.07 11:27:07 277 INFO
2004.02.07 11:27:07 277 INFO
2004.02.07 11:27:07 277 INFO    CH8 closing connection
2004.02.07 11:27:07 277 INFO    ConnectionHandler CH8 waiting for connection
2004.02.07 11:27:07 280 INFO    CH9: UNBIND
2004.02.07 11:27:07 280 INFO    Hex dump (16) bytes:
2004.02.07 11:27:07 281 INFO    00000010:00000006:00000000:00000005:
2004.02.07 11:27:07 281 INFO
2004.02.07 11:27:07 281 INFO
2004.02.07 11:27:07 281 INFO    CH9: UNBIND_RESP
2004.02.07 11:27:07 281 INFO    Hex dump (16) bytes:
2004.02.07 11:27:07 281 INFO    00000010:80000006:00000000:00000005:
2004.02.07 11:27:07 281 INFO
2004.02.07 11:27:07 281 INFO
2004.02.07 11:27:07 281 INFO    CH9 closing connection
2004.02.07 11:27:07 281 INFO    ConnectionHandler CH9 waiting for connection
</pre>

<p>Now that we have our ESME stopped, and unbound from the SMSC simulator, if
you try to send another message through your browser, you'll get:</p>

<pre>
    No receiver available to deliver messageHTTP/1.1 200

    DELIVER_SM invoked OK
</pre>

<p>Let's dig into the details of the echo ESME implementation.</p>

<p>If you look at the documentation for the <a href="gen_esme.html">gen_esme
</a> behavior, you will find all the exported functions and callbacks available
on this behavior.  Notice there is an exported function for every SMPP 
operation an ESME may issue.  Among others, these functions are exported:</p>

<ul>
  <li>alert_notification</li>
  <li>bind_receiver</li>
  <li>bind_transceiver</li>
  <li>bind_transmitter</li>
  <li>broadcast_sm</li>
  <li>cancel_broadcast_sm</li>
  <li>cancel_sm</li>
  <li>data_sm</li>
  <li>query_broadcast_sm</li>
  <li>query_sm</li>
  <li>replace_sm</li>
  <li>submit_multi</li>
  <li>submit_sm</li>
  <li>unbind</li>
</ul>

<p>As we mention, there are some other functions, most of them need to be 
exported to implement the gen_server and <a href="gen_esme_session.html">
gen_esme_session</a> behaviors, upon which <a href="gen_esme.html">gen_esme</a>
was implemented.  Let us ignore the rest of the exported functions at this 
moment.</p>

<p>Recall <a href="gen_esme.html#submit_sm-2">gen_esme:submit_sm/2</a> function
and how it was used in our <a href="echo_esme.html">echo_esme</a> example.</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
handle_operation({deliver_sm, _Session, Pdu}, From, S) -&gt;
    Mesg = sm:message_user_data(Pdu),   % gets incoming short message
    Dest = sm:reply_address(Pdu),       % source address as response address
    io:format("Echoing SM: ~p~n", [Mesg]),
    spawn(fun() -&gt; gen_esme:submit_sm(S#state.trx_session, [Mesg|Dest]) end),
    {reply, {ok, []}, S};
</pre>
    </td>
  </tr>
</table>

<p>See how to submit a short message from our ESME.  Just need to call
<a href="gen_esme.html#submit_sm-2">gen_esme:submit_sm/2</a>.  This function 
is declared as follows:</p>

<p><tt>submit_sm(Session::Session, ParamList::ParamList) -&gt; Result</tt>
</p>

<ul>
  <li>Session = pid()</li>
  <li>ParamList = [{ParamName, ParamValue}]</li>
  <li>ParamName = atom()</li>
  <li>ParamValue = term()</li>
  <li>Result = {ok, PduResp} | {error, Error}</li>
  <li>PduResp = pdu()</li>
  <li>Error = {error_code, int()} | atom()</li>
</ul>

<p>The first argument is the <tt>pid()</tt> of the session. The second one
(<tt>ParamList</tt>) holds the parameter values we are going to send 
along in our PDU.  This argument is an assoc list; the items on this list are 
pairs in the format <tt>{ParamName, ParamValue}</tt>.
</p>

<p>Let me rewrite the code above without using the <a href="sm.html">sm</a> 
module, so you can see all the details:
</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
handle_operation({deliver_sm, _Session, Pdu}, From, S) -&gt;
    % First of all, lets get the source address.

    SourceAddrTon = operation:get_param(source_addr_ton, Pdu),
    SourceAddrNpi = operation:get_param(source_addr_npi, Pdu),
    SourceAddr    = operation:get_param(source_addr,     Pdu),

    % Get the message payload from the incoming PDU. 
    % Since we don't know if the SMSC sends the short message using the
    % short_message or the message_payload parameter, we have to look which
    % one is used.
    %
    %  We'd also want to respond using the same parameter the SMSC uses.

    MessageUserData = 
        case operation:get_param(short_message, Pdu) of
            ShortMessage when ShortMessage == ""; ShortMessage == undefined -&gt;
                {message_payload, operation:get_param(message_payload, Pdu)};
            ShortMessage -&gt;
                {short_message, ShortMessage}
        end,

    % Now we're ready to create the parameter list for our response

    ResponseAddr = [{dest_addr_ton,    SourceAddrTon},
                    {dest_addr_npi,    SourceAddrNpi},
                    {destination_addr, SourceAddr}],

    ParamList = [MessageUserData|ResponseAddr],

    io:format("Echoing SM: ~p~n", [MessageUserData]),
    spawn(fun() -&gt; gen_esme:submit_sm(S#state.trx_session, [Mesg|Dest]) end),
    {reply, {ok, []}, S};
</pre>
    </td>
  </tr>
</table>

<p>Since getting the <i>message_payload</i> and creating the response address 
from the source address are common operations, both have been implemented in 
<a href="sm.html">sm.erl</a> module by the functions 
<a href="sm.html#message_user_data-1">sm:message_user_data/1</a> and 
<a href="sm.html#reply_address-1">sm:reply_address/1</a> respectively.</p>

<p><a href="gen_esme.htmlsubmit_sm-2">gen_esme:submit_sm/2</a> creates a 
<i>submit_sm</i> PDU using the values in the parameter list.  For those 
parameters not defined in the parameter list, the default value is used. 
Default values for every parameter are defined in 
<a href="../../include/smpp_param.hrl">smpp_param.hrl</a>.  Values in 
<tt>ParamList</tt> override defaults.</p>

<p>Parameter names and types are those in the SMPP specification, should you 
find any problems assigning values to an specific parameter, check their exact
names and types in <a href="../../include/smpp_param.hrl">smpp_param.hrl</a>.
</p>

<p>SMPP composite parameters were defined as records.  For example, values for 
<i>unsuccess_sme</i> parameters must be defined by means of the 
<tt>unsuccess_sme</tt> record (defined in 
<a href="../../include/smpp_base.hrl">smpp_base.hrl</a>).</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
%%%
% %@spec {unsuccess_sme,
%         DestAddrTon,
%         DestAddrNpi,
%         DestinationAddr,
%         ErrorStatusCode}
%    DestAddrTon     = int()
%    DestAddrNpi     = int()
%    DestinationAddr = string()
%    ErrorStatusCode = int()
%
% %@doc unsuccess_sme composite record definition.
%
% &lt;p&gt;The macro ?UNSUCCESS_SME_DATATYPE defines the type specifier for this
% field.&lt;/p&gt;
%
% &lt;dl&gt;
%   &lt;dt&gt;DestAddrTon: &lt;/dt&gt;&lt;dd&gt;Indicates Type of Number for destination.
%     Integer, 1 octet (default is ?TON_INTERNATIONAL).
%   &lt;/dd&gt;
%   &lt;dt&gt;DestAddrNpi: &lt;/dt&gt;&lt;dd&gt;Numbering Plan Indicator for destination.
%     Integer, 1 octet  (default is ?NPI_ISDN).
%   &lt;/dd&gt;
%   &lt;dt&gt;DestinationAddr: &lt;/dt&gt;&lt;dd&gt;Destination address of this short message.
%     For mobile terminated messages, this is the directory number of the
%     recipient MS.  C-Octet String, Var. max 21 octets.
%   &lt;/dd&gt;
%   &lt;dt&gt;ErrorStatusCode: &lt;/dt&gt;&lt;dd&gt;Indicates the success or failure of the
%     submit_multi request to this SME address.  Check command_status
%     macros for a complete list of SMPP Error codes.  Integer, 4 octets.
%   &lt;/dd&gt;
% &lt;/dl&gt;
% %@end
%%
-record(unsuccess_sme,
        {dest_addr_ton     = ?TON_INTERNATIONAL,
         dest_addr_npi     = ?NPI_ISDN,
         destination_addr,
         error_status_code}).
</pre>
    </td>
  </tr>
</table>

<p>The rest of SMPP operation functions have a <tt>ParamList</tt> 
argument also, and work much like <a href="gen_esme.html#submit_sm-2">
gen_esme:submit_sm/2</a> does.</p>

<p>Look at the callbacks exported by the <a href="gen_esme.html">gen_esme</a> 
behavior, to see how much you can customize your particular ESME 
implementation.  Leaving a callback undefined <strong>crashes</strong> the 
entire ESME server whenever that function is called.</p>


<h3><a name="howto_smsc">How to implement a SMSC</a></h3>

<p>Since OSERL version 1.1 a <a href="gen_smsc.html">gen_smsc</a> behavior has 
been included to simplify SMSC implementations.</p>


<h4><a name="smsc_skel">SMSC skeleton</a></h4>

<p>OSERL ships a SMSC skeleton which might be a good starting point for your
SMSC development.</p>

<p>Find the <a href="smsc_skel.html">smsc_skel</a> module under
<a href="examples/smsc_skel.erl">doc/examples/smsc_skel.erl</a>.</p>


<h4><a name="test">Test SMSC</a></h4>

<p>There's a simple <a href="test_smsc.html">test SMSC</a> example under 
<a href="examples/test_smsc.erl">doc/examples/test_smsc.erl</a>.</p>

<p>Let's compile this SMSC as usual and test our sample ESME.</p>

<pre>
    $ erlc -W -I ../../include -pz ../../ebin test_smsc.erl

    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; executing user profile in HOME/.erlang
    .erlang rc finished
    1&gt; code:add_path("../../../common_lib/ebin").
    true
    2&gt; code:add_path("../../ebin").
    true
    3&gt; test_smsc:start_link().
    true
</pre>

<p>Open another erlang shell and start the <a href="echo_esme.html">echo_esme
</a>.</p>

<pre>
    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; executing user profile in HOME/.erlang
    .erlang rc finished
    1&gt; code:add_path("../../../common_lib/ebin").
    true
    2&gt; code:add_path("../../ebin").
    true
    3&gt; echo_esme:start_link().
    {ok,&lt;0.39.0&gt;}
</pre>

<p>Good, now go back to the SMSC shell and deliver a SM to see what happens.
</p>

<pre>
    bound_trx: &lt;0.42.0&gt;
    4&gt; test_smsc:deliver_sm("123456789", "hello there").
    ok
    submit_sm: "123456789" - "hello there"
</pre>

<p>Check the output on the ESME shell:</p>

<pre>
    Echoing SM: {short_message,"hello there"}
</pre>

<p>Go ahead and start the <a href="submit_esme.html">submit_esme</a>, you may
start it within the same shell than the <a href="echo_esme.html">echo_esme</a>.
</p>

<pre>
    4&gt; submit_esme:start_link().
    {ok,&lt;0.48.0&gt;}
    5&gt; submit_esme:submit_sm("987654321", "hola").
    "Service type&gt; "CMT
    "Source&gt; "1950
    "Replace if present flag&gt; "0
    "Schedule delivery time&gt; "040207105523000+
    "Validity period&gt; "040207105523000+
    "Esm class&gt; "0
    "Priority flag&gt; "0
    "Registered delivery&gt; "0
    "Sm default msg id&gt; "0
    "How many times to submit this message (load test)"5
    ok
    Message ID: "1"
    Message ID: "2"
    Message ID: "3"
    Message ID: "4"
    Message ID: "5"
    6&gt; echo_esme:stop().
    ok
    7&gt; halt().
</pre>

<p>During that sequence, the output on the SMSC shell should be something like
the following.</p>

<pre>
    bound_tx: &lt;0.49.0&gt;
    submit_sm: "987654321" - "hola"
    submit_sm: "987654321" - "hola"
    submit_sm: "987654321" - "hola"
    submit_sm: "987654321" - "hola"
    submit_sm: "987654321" - "hola"
    unbind: &lt;0.42.0&gt;
    trx_session closed: &lt;0.42.0&gt;
    tx_session failure: &lt;0.49.0&gt; - {recv_error,{error,closed}}
    4&gt; test_smsc:stop().
    ok
</pre>

<p>Notice the <tt>tx_session failure</tt>, recall we halted without stopping
the <a href="submit_esme.html">submit_esme</a>.</p>


<h3><a name="tune">Fine tune OSERL's SMPP implementation</a></h3>

In order to fit OSERL to your particular needs, you may want to fine tune
some parameters and/or PDU definitions of the SMPP protocol.

<p>Redefining SMPP PDUs and parameters in OSERL is simple, since OSERL was
designed with that principle in mind.</p>

<p>There are three header files you should consider, if you want to customize
the SMPP protocol definitions:</p>

<dl>
  <dt><a href="#smpp_pdu">smpp_pdu.hrl</a></dt>
  <dd>PDUs type descriptor.</dd>
  <dt><a href="#smpp_param">smpp_param.hrl</a></dt>
  <dd>Standard and TLV parameters descriptor.</dd>
  <dt><a href="#smpp_base">smpp_base.hrl</a></dt>
  <dd>Parameters base type.</dd>
</dl>

<b>Important Note: </b><i>Don't forget to recompile the module
<a href="operation.html">operation.erl</a> for changes on any of these 
files to take effect.</i>


<h4><a name="smpp_pdu">smpp_pdu.hrl</a></h4>

This header defines the SMPP PDU Type Declarations.

<p>Macros declaring SMPP PDU definitions and their default values.  Refer 
to <a href="operation.html">operation.erl</a> to find out how these macros 
are used.</p>

<p>Every PDU declaration consists of a <i>command_id</i> and a couple of 
lists.</p>

<dl>
  <dt><i>Standard body parameters declaration:</i></dt><dd>A list with the
    declaration of every standard parameter of the PDU body.  Header 
    parameters are *not* included on the PDU declaration.  The standard
    parameters are packed/unpacked in the order specified on this list, thus
    the order must be the one declared on [SMPP 5.0].
  </dd>
  <dt><i>TLV parameters declaration:</i></dt><dd>A list with the declaration
    of every TLV parameter of the PDU.  

    <p>Programmers may want to comment out, uncomment or even add any 
    desired TLV in order to fit the needs of a particular implementation.
    Notice that having declared unused TLVs doesn't do any harm, comment
    them out or remove'em from the TLV list on the PDU declaration only for
    efficiency sake.</p>
  </dd>
</dl>

<p>Given the following declaration:</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(BIND_TRANSMITTER_RESP,
        ?PDU(?COMMAND_ID_BIND_TRANSMITTER_RESP,
             [?SYSTEM_ID],
             [?CONGESTION_STATE,
              ?SC_INTERFACE_VERSION])).
</pre>
    </td>
  </tr>
</table>

<p>A dictionary representing this PDU must have the elements:</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
[{command_id, ?COMMAND_ID_BIND_TRANSMITTER_RESP},
 {command_status, CommandStatus},
 {sequence_number, SequenceNumber},
 {system_id, SystemId}]
</pre>
    </td>
  </tr>
</table>

<p>The pair <tt>{system_id, SystemId}</tt> might be ignored if 
<tt>command_status</tt> is not 0. Following pairs are also optional:</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
[{congestion_state, CongestionState}, 
 {sc_interface_version, ScInterfaceVersion}]
</pre>
    </td>
  </tr>
</table>

<p>Notice that a <tt>command_length</tt> element is not included in the 
dictionary.</p>


<h4><a name="smpp_param">smpp_param.hrl</a></h4>

SMPP Standard and TLV Parameters descriptor.  These descriptors are defined by 
means of the base types declared on <a href="#smpp_base">smpp_base</a>,
and using the parameter syntax defined in <i>param_syntax.hrl</i>.

<p>A parameter descriptor defines the parameter name, base type, default value
and error code associated to it.</p>

<p>Feel free to adjust parameter descriptors to your particular needs.  You may
want to change the default value or the mandatory status of some TLVs.</p>


<h4><a name="smpp_base">smpp_base.hrl</a></h4>

Base definitions for the SMPP protocol specification.  These definitions use 
the base syntax defined in <i>base_syntax.hrl</i>.

<p>In this header file, parameter base datatypes, domains and reserved values
are declared.</p>


<h2><a name="storage">PDU data storage</a></h2>

PDU data is internally stored as a dictionary.  Dictionaries are defined on 
erlang's <a href="http://www.erlang.se/doc/doc-5.0.1/lib/stdlib-1.9.1/doc/">stdlib</a>.  Functions <a href="operation.html#get_param-2#">operation:get_param/2</a> and <a href="operation.html#set_param-3#">operation:set_param/3</a> may be used to get/set parameters values by name.

<p>The names of the parameters (keys of the PDU dictionary) are those on the 
SMPP protocol specification.</p>

<p>A PDU is completely defined by the content (the dictionary with the 
parameter values) and a type descriptor (terms described in the following
section).  Type descriptors declare the PDU structure, and determines the
way it must be encoded/decoded.</p>

<p>To successfully encode/decode PDU contents into binary terms, every
individual parameter value must match the type declared on the PDU descriptor. 
Users of this library won't need to care about type descriptors though.  The
<a href="http://www.des.udc.es/~mpquique/oserl/operation.html">operation</a>
module hides the details to higher layers and transparently handles the
type descriptors.</p>


<h2><a name="translation">Translating the SMPP specification</a></h2>

<p><i>Only those developers interested in the implementation details
of the library should read this section.</i>  Those who only want to use
the API, and don't care much about how things were done, may safely skip this 
section.</p>

<p>The erlang terms used to represent the SMPP specification are intended to
adopt the conventions used on [SMPP 5.0] as much as posible.</p>

<p>The best way to understand the syntax used in OSERL to represent PDU type
descriptors, and how everything works, is by a complete example.</p>

<p>On page 74, section 4.2.3.2 of the SMPP specification [SMPP 5.0], the
<i>submit_multi_resp</i> operation PDU is defined as follows:</p>

<table width="100%" border="1" cellpadding="2">
<caption>submit_multi_resp Syntax</caption>
  <tr style="color: white; background-color : black"> 
    <th width="50%" valign="middle" align="center">Field Name</th>
    <th width="25%" valign="middle" align="center">Size Octets</th>
    <th width="25%" valign="middle" align="center">Type</th>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">command_length</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">command_id</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">command_status</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">sequence_number</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">message_id</td>
    <td width="25%" valign="middle" align="center">Var. max 65</td>
    <td width="25%" valign="middle" align="center">C-Octet String</td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">no_unsuccess</td>
    <td width="25%" valign="middle" align="center">1</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">unsuccess_sme</td>
    <td width="25%" valign="middle" align="center">Var. max 27</td>
    <td width="25%" valign="middle" align="center">Composite</td>
  </tr>
  <tr>
    <td width="50%" valign="middle" align="center">
      <table width="100%" border="0" cellpadding="2">
        <tr>
          <td width="100%" align="center">dest_addr_ton</td>
        </tr>
        <tr>
          <td width="100%" align="center">dest_addr_npi</td>
        </tr>
        <tr>
          <td width="100%" align="center">destination_addr</td>
        </tr>
        <tr>
          <td width="100%" align="center">error_status_code</td>
        </tr>
      </table>
    </td>
    <td width="25%" valign="middle" align="center">
      <table width="100%" border="0" cellpadding="2">
        <tr>
          <td width="100%" align="center">1</td>
        </tr>
        <tr>
          <td width="100%" align="center">1</td>
        </tr>
        <tr>
          <td width="100%" align="center">Var. max 21</td>
        </tr>
        <tr>
          <td width="100%" align="center">4</td>
        </tr>
      </table>
    </td>
    <td width="25%" valign="middle" align="center">
      <table width="100%" border="0" cellpadding="2">
        <tr>
          <td width="100%" align="center">Integer</td>
        </tr>
        <tr>
          <td width="100%" align="center">Integer</td>
        </tr>
        <tr>
          <td width="100%" align="center">C-Octet String</td>
        </tr>
        <tr>
          <td width="100%" align="center">Integer</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">
      Message Submission Response TLVs
    </td>
    <td width="25%" valign="middle" align="center">Var</td>
    <td width="25%" valign="middle" align="center">TLV</td>
  </tr>
</table>

<p><tt>unsuccess_sme</tt> is a composite field containing an SME address 
(<tt>dest_addr_ton</tt>, <tt>dest_addr_npi</tt> and <tt>destination_addr</tt>) 
and an error code (<tt>error_status_code</tt>).  Additionally the field can be 
encoded multiple times according to the value specified in the 
<tt>no_unsuccess</tt> field.</p>

<table width="100%" border="1" cellpadding="2">
<caption>Message Submission Response TLVs</caption>
  <tr style="color: white; background-color : black"> 
    <th width="40%" valign="middle" align="center">TLV Name</th>
    <th width="20%" valign="middle" align="center">Tag</th>
    <th width="20%" valign="middle" align="center">Size Octets</th>
    <th width="20%" valign="middle" align="center">Type</th>
  </tr>
  <tr>
    <td width="40%" valign="middle" align="center">
      additional_status_info_text
    </td>
    <td width="20%" valign="middle" align="center">0x001D</td>
    <td width="20%" valign="middle" align="center">1-256</td>
    <td width="20%" valign="middle" align="center">C-Octet String</td>
  </tr>
  <tr>
    <td width="30%" valign="middle" align="center">delivery_failure_reason</td>
    <td width="20%" valign="middle" align="center">0x0425</td>
    <td width="20%" valign="middle" align="center">1</td>
    <td width="20%" valign="middle" align="center">Integer</td>
  </tr>
  <tr>
    <td width="30%" valign="middle" align="center">dpf_result</td>
    <td width="20%" valign="middle" align="center">0x0420</td>
    <td width="20%" valign="middle" align="center">1</td>
    <td width="20%" valign="middle" align="center">Integer</td>
  </tr>
  <tr>
    <td width="30%" valign="middle" align="center">network_error_code</td>
    <td width="20%" valign="middle" align="center">0x0423</td>
    <td width="20%" valign="middle" align="center">3</td>
    <td width="20%" valign="middle" align="center">Octet String</td>
  </tr>
</table>

<p>This PDU type is internaly represented by the following descriptor:</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(SUBMIT_MULTI_RESP,
        ?PDU(?COMMAND_ID_SUBMIT_MULTI_RESP,
             [?MESSAGE_ID, 
              ?UNSUCCESS_SME],
             [?ADDITIONAL_STATUS_INFO_TEXT,
              ?CONGESTION_STATE,
              ?DELIVERY_FAILURE_REASON,
              ?DPF_RESULT,
              ?NETWORK_ERROR_CODE])).
</pre>
    </td>
  </tr>
</table>

<p>This macro definition can be found in the header file 
<b>smpp_pdu.hrl</b></p>

<p>Since the format of the header is common to every PDU type, it doesn't need
to be declared.</p>

<p>Recalling the internal representation of the PDU, every individual field is 
defined in <b>smpp_param.hrl</b> as:</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(MESSAGE_ID, 
        ?STANDARD(message_id, 
                  ?MESSAGE_ID_DOMAIN, 
                  ?NULL_C_OCTET_STRING,
                  ?ESME_RINVMSGID)).

-define(UNSUCCESS_SME, 
        ?STANDARD(unsuccess_sme, 
                  ?UNSUCCESS_SME_DOMAIN,
                  undefined, 
                  ?ESME_RINVDSTADR)).

-define(ADDITIONAL_STATUS_INFO_TEXT, 
        ?OPTIONAL_TLV(additional_status_info_text,
                      16#001D, 
                      ?ADDITIONAL_STATUS_INFO_TEXT_DOMAIN, 
                      ?ADDITIONAL_STATUS_INFO_TEXT_RESERVED, 
                      undefined, 
                      undefined)).

-define(CONGESTION_STATE, 
        ?OPTIONAL_TLV(congestion_state,
                      16#0428, 
                      ?CONGESTION_STATE_DOMAIN, 
                      ?CONGESTION_STATE_RESERVED, 
                      undefined, 
                      undefined)).

-define(DELIVERY_FAILURE_REASON, 
        ?OPTIONAL_TLV(delivery_failure_reason,
                      16#0425, 
                      ?DELIVERY_FAILURE_REASON_DOMAIN, 
                      ?DELIVERY_FAILURE_REASON_RESERVED, 
                      undefined, 
                      undefined)).

-define(DPF_RESULT, 
        ?OPTIONAL_TLV(dpf_result,
                      16#0420, 
                      ?DPF_RESULT_DOMAIN, 
                      ?DPF_RESULT_RESERVED, 
                      ?DPF_RESULT_NOT_SET, 
                      undefined)).

-define(NETWORK_ERROR_CODE, 
        ?OPTIONAL_TLV(network_error_code,
                      16#0423, 
                      ?NETWORK_ERROR_CODE_DOMAIN, 
                      ?NETWORK_ERROR_CODE_RESERVED, 
                      undefined, 
                      undefined)).
</pre>
    </td>
  </tr>
</table>

<p>These parameter descriptors were defined by means of some macros
declared in the <a href="#param">parameter syntax</a>.</p>

<p>Domains and reserved values are defined in <b>smpp_base.hrl</b>.</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
%%%
% message_id
%%
-define(MESSAGE_ID_DOMAIN, ?VAR_C_OCTET_STRING(65)).

%%%
% unsuccess_sme
%%
-define(UNSUCCESS_SME_ITEM_DOMAIN,
        ?COMPOSITE(unsuccess_sme,
                   {?TON_DOMAIN,
                    ?NPI_DOMAIN,
                    ?ADDR_21_DOMAIN,
                    ?SMPP_ERROR_DOMAIN})).

-define(UNSUCCESS_SME_DOMAIN, ?LIST(?UNSUCCESS_SME_ITEM_DOMAIN)).

%%%
% additional_status_info_text
%%
-define(ADDITIONAL_STATUS_INFO_TEXT_DOMAIN,   ?VAR_C_OCTET_STRING(256)).
-define(ADDITIONAL_STATUS_INFO_TEXT_RESERVED, ?EMPTY).

%%%
% congestion_state
%%
-define(CONGESTION_STATE_DOMAIN,   ?BOUND_INTEGER(1, 99)).
-define(CONGESTION_STATE_RESERVED, ?RANGE_INTEGER(1, 100, 255)).

%%%
% delivery_failure_reason
%%
-define(DELIVERY_FAILURE_REASON_DOMAIN,   ?BOUND_INTEGER(1, 3)).
-define(DELIVERY_FAILURE_REASON_RESERVED, ?RANGE_INTEGER(1, 4, 255)).

%%%
% dpf_result
%%
-define(DPF_RESULT_DOMAIN,   ?BOUND_INTEGER(1, 1)).
-define(DPF_RESULT_RESERVED, ?RANGE_INTEGER(1, 2, 255)).

%%%
% network_error_code
%%
-define(NETWORK_ERROR_CODE_TYPE_DOMAIN,   ?RANGE_INTEGER(1, 1, 8)).
-define(NETWORK_ERROR_CODE_TYPE_RESERVED,   
        ?UNION([?CONSTANT(0), ?RANGE_INTEGER(1, 9, 255)])).

-define(NETWORK_ERROR_CODE_ERROR_DOMAIN,   ?INTEGER(2)).
-define(NETWORK_ERROR_CODE_ERROR_RESERVED, ?INTEGER(2)).

-define(NETWORK_ERROR_CODE_DOMAIN, 
        ?COMPOSITE(network_error_code,
                   {?NETWORK_ERROR_CODE_TYPE_DOMAIN,
                    ?NETWORK_ERROR_CODE_ERROR_DOMAIN})).
-define(NETWORK_ERROR_CODE_RESERVED, 
        ?COMPOSITE(network_error_code,
                   {?NETWORK_ERROR_CODE_TYPE_RESERVED,
                    ?NETWORK_ERROR_CODE_ERROR_RESERVED})).
</pre>
    </td>
  </tr>
</table>


<p>Notice that <tt>UNSUCCESS_SME_DOMAIN</tt> embraces the definition of both 
fields; <tt>unsuccess_sme</tt> and <tt>no_unsuccess</tt>, since a list is 
<a href="base_syntax.html#encode-list">encoded in a Length ++ List</a> fashion,
<tt>no_unsuccess</tt> doesn't need to be explicitly declared.</p>

<p>Additionally, two records must be defined in order to successfully decode 
named composites:</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-record(unsuccess_sme, 
        {dest_addr_ton     = ?TON_INTERNATIONAL,
         dest_addr_npi     = ?NPI_ISDN,
         destination_addr,
         error_status_code}).

-record(network_error_code, 
        {type  = ?NETWORK_ERROR_CODE_TYPE_GSM,
         error}).
</pre>
    </td>
  </tr>
</table>

<p>Record identifiers must match the names provided in the composite 
declaration for the decoding function to work propertly.  These names are 
ignored by the encode function though.</p>

<p>Please read documentation, comments and examples on the source code for 
further details.</p>


<h2><a name="base">Base Syntax</a></h2>

<p>The base syntax is an internal representation for the base types defined on
the SMPP specification.</p>

<p>Some base types are explicitly defined on the protocol specification, but
many of them didn't became necessary until the PDUs were examined in greater 
detail.  Data-types like <tt>lists</tt> or <tt>composites</tt> are needed to
support PDU fields that may appear multiple times, or fields that happen to
be always grouped together inside a given PDU definition.</p>

<p>The following base types are defined as records on the base syntax:</p>

<ol>
  <li><a href="#constant">constant</a></li>
  <li><a href="#integer">integer</a></li>
  <li><a href="#c_octet_string">c_octet_string</a></li>
  <li><a href="#octet_string">octet_string</a></li>
  <li><a href="#list">list</a></li>
  <li><a href="#composite">composite</a></li>
  <li><a href="#union">union</a></li>
</ol>


<h3><a name="constant">constant</a></h3>

<p><tt>-record(constant, {value})</tt>
  <ul>
    <li><tt>Value = bin()</tt></li>
  </ul>
</p>

<p>Constant declaration.  Constants are defined in binary format and
their value is packed as is.</p>

<dl>
  <dt>Value: </dt><dd>Binary constant value.</dd>
</dl>


<h3><a name="integer">integer</a></h3>

<p><tt>-record(integer, {size, min, max})</tt>
  <ul>
    <li><tt>Size = int()</tt></li>
    <li><tt>Min  = int()</tt></li>
    <li><tt>Max  = int()</tt></li>
  </ul>
</p>

<p>Integer data-type declaration.</p>

<dl>
  <dt>Size: </dt><dd>Size in octets.</dd>
  <dt>Min: </dt><dd>Lower limit (included).</dd>
  <dt>Max: </dt><dd>Upper limit (included).</dd>
</dl>

<p>Refer to section 3.1 on [SMPP 5.0]</p>


<h3><a name="c_octet_string">c_octet_string</a></h3>

<p><tt>-record(c_octet_string, {fixed, size, format})</tt>
  <ul>
    <li><tt>Fixed  = bool()</tt></li>
    <li><tt>Size   = int()</tt></li>
    <li><tt>Format = fun(string()) -&gt; bool()</tt></li>
  </ul>
</p>

<p>C-Octet String data-type declaration.  A C-Octet String must always 
be NULL terminated, thus the minimun length allowed is 1 octet.</p>

<dl>
  <dt>Fixed: </dt><dd>String size may be of variable or fixed length.  When
    fixed the length must be exactly Size octets long, if not fixed it may
    be from 1 up to Size octets long.
  </dd>
  <dt>Size: </dt><dd>Size in octets.</dd>
  <dt>Format: </dt><dd>If a format predicate is given, the string will be
    valid if the C-Octet String satisfies <tt>Format</tt>.
  </dd>
</dl>

<p>Refer to section 3.1 on [SMPP 5.0]</p>


<h3><a name="octet_string">octet_string</a></h3>

<p><tt>-record(octet_string, {fixed, size, format})</tt>
  <ul>
    <li><tt>Fixed  = bool()</tt></li>
    <li><tt>Size   = int()</tt></li>
    <li><tt>Format = fun(string()) -&gt; bool()</tt></li>
  </ul>
</p>

<p>Octet String data-type declaration.  An Octet String is not necessary
to be NULL terminated, thus the minimun length allowed is 0 octets.</p>

<dl>
  <dt>Fixed: </dt><dd>String size may be of variable or fixed length.  When
    fixed the length must be exactly Size octets long, if not fixed it may
    be from 0 up to Size octets long.
  </dd>
  <dt>Size: </dt><dd>Size in octets.</dd>
  <dt>Format: </dt><dd>If a format predicate is given, the string will be
    valid if the C-Octet String satisfies <tt>Format</tt>.
  </dd>
</dl>

<p>Refer to section 3.1 on [SMPP 5.0]</p>


<h3><a name="list">list</a></h3>

<p><tt>-record(list, {type, size})</tt>
  <ul>
    <li><tt>Type     = {constant, Value}</tt>
           <br/><tt> | {integer, Size, Min, Max}</tt>
           <br/><tt> | {c_octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {list, Type, Size}</tt>
           <br/><tt> | {composite, Name, Tuple}</tt>
           <br/><tt> | {union, Types}</tt></li>   
    <li><tt>Value    = bin()</tt></li>
    <li><tt>Size     = int()</tt></li>
    <li><tt>Min      = int()</tt></li>
    <li><tt>Max      = int()</tt></li>
    <li><tt>Format   = free | hex | dec</tt></li>
    <li><tt>Fixed    = bool()</tt></li>
    <li><tt>Name     = atom()</tt></li>
    <li><tt>Tuple    = term()</tt></li>
    <li><tt>Types    = [Type]</tt></li>
  </ul>
</p>

<p>List data-type declaration.  Represents a list with elements of
the same Type.</p>

<p>Notice that nested data-type definitions are allowed.  Type could be:</p>

<ul>
  <li>a constant, even it doesn't make much sense.</li>
  <li>basic data-type; integer, c_octet_string or octet_string.  A list
    of basic values.
  </li>
  <li>complex data-type such as tlvs lists, composites or union
     declarations.
  </li>
</ul>

<dl>
  <dt>Type: </dt><dd>Defines the type of the elements on the list.  Any
    kind of data-type declaration is valid.
  </dd>
  <dt>Size: </dt><dd>Maximum number of elements.</dd>
</dl>


<h3><a name="composite">composite</a></h3>

<p><tt>-record(composite, {name, tuple})</tt>
  <ul>
    <li><tt>Name  = atom()</tt></li>
    <li><tt>Tuple = term()</tt></li>
  </ul>
</p>

<p>Composite data-type declaration.  If <tt>Name</tt> is undefined the
composite is said to be anonymous and thus represented by a tuple.  Named 
composites are represented by records of type <tt>Name</tt>.  It is 
responsibility of the programmer to provide the appropriate record 
definitions.</p>

<p><tt>Name</tt> is ignored when encoding the value into a binary stream.  It
is only considered to translate the binary representation of a composite
into erlang records.  It also helps to document the declaration of nested
data structures.  It'll be a good practice to give the composite (and the
associated record) the same <tt>Name</tt> that the SMPP Protocol
Specification uses [SMPP 5.0].</p>  

<p>Whether named or not, <tt>Tuple</tt> is a tuple (never a record) defining 
the type structure of the composite.  For example, in a composite with two 
fields; an integer and an octet_string, <tt>Tuple</tt> would be something 
like:</p>

<p><tt>{?INTEGER_4, VAR_OCTET_STRING(21)}</tt></p>

<p>Nested data-type definitions are allowed.  An element on the composite may
be of the type:</p>

<ul>
  <li>constants.</li>
  <li>basic data-types; integer, c_octet_string or octet_string.</li>
  <li>complex data-types such as lists, composites or union declarations.</li>
</ul>

<dl>
  <dt>Name: </dt><dd>Identifier of the composite.  Must be left undefined if
    the composite is anonymous.
  </dd>
  <dt>Tuple: </dt><dd>Defines the structure of the composite.  Any kind of 
    data-type declaration is a valid term of this tuple.
  </dd>
</dl>


<h3><a name="union">union</a></h3>

<p><tt>-record(union, {types})</tt>
  <ul>
    <li><tt>Types    = [Type]</tt></li>
    <li><tt>Type     = {constant, Value}</tt>
           <br/><tt> | {integer, Size, Min, Max}</tt>
           <br/><tt> | {c_octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {list, Type, Size}</tt>
           <br/><tt> | {composite, Name, Tuple}</tt>
           <br/><tt> | {union, Types}</tt></li>
    <li><tt>Value    = bin()</tt></li>
    <li><tt>Size     = int()</tt></li>
    <li><tt>Min      = int()</tt></li>
    <li><tt>Max      = int()</tt></li>
    <li><tt>Fixed    = bool()</tt></li>
    <li><tt>Format   = free | hex | dec</tt></li>
    <li><tt>Name     = atom()</tt></li>
    <li><tt>Tuple    = term()</tt></li>
  </ul>
</p>

<p>Union data-type declaration.  Defines a new type which is the union of
<tt>types</tt>.  For example the destination address in a <i>submit_multi</i> 
command represents either a distribution list or an SME address (these 
addresses have different data-types).</p>

<p><tt>{union, [SmeAddress, DlAddress]}</tt></p>

<p>where <tt>SmeAddress</tt> and <tt>DlAddress</tt> are composite 
data-type definitions.  Notice that nested data-type declarations are
allowed.  In SMPP the union declaration is mainly used in examples like
the one above mentioned, where the union types are composites.</p>

<dl>
  <dt>Types: </dt><dd>A list with the types of the union.</dd>
</dl>


<h2><a name="basemacros">Base Syntax Macros</a></h2>

<p>Macros based on record data-types definitions</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(CONSTANT(Value), 
        #constant{value = Value}).
-define(INTEGER(Size), 
        #integer{size = Size, min = 0, max = math:pow(256, Size) - 1}).
-define(C_OCTET_STRING(Fixed, Size),
        #c_octet_string{fixed = Fixed, size = Size, format = free}).
-define(OCTET_STRING(Fixed, Size),
        #octet_string{fixed = Fixed, size = Size, format = free}).
-define(LIST(Type), 
        #list{type = Type, size = 255}).
-define(COMPOSITE(Name, Tuple), 
        #composite{name = Name, tuple = Tuple}).
-define(UNION(Types), 
        #union{types = Types}).
</pre>
    </td>
  </tr>
</table>


<p>Simplified macros, some options are implicitly assigned.  Most of the SMPP 
PDU fields definitions are more readable using these macros.</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(BOUND_INTEGER(Size, Max), 
        #integer{size = Size, min = 0, max = Max}).
-define(RANGE_INTEGER(Size, Min, Max), 
        #integer{size = Size, min = Min, max = Max}).

-define(HEX_C_OCTET_STRING(Fixed, Size),
        #c_octet_string{
            fixed  = Fixed, 
            size   = Size, 
            format = fun(Str) -> my_string:is_hex(Str) end}).
-define(HEX_OCTET_STRING(Fixed, Size),
        #octet_string{
            fixed  = Fixed, 
            size   = Size, 
            format = fun(Str) -> my_string:is_hex(Str) end}).

-define(DEC_C_OCTET_STRING(Fixed, Size),
        #c_octet_string{
            fixed  = Fixed, 
            size   = Size, 
            format = fun(Str) -> my_string:is_dec(Str) end}).
-define(DEC_OCTET_STRING(Fixed, Size),
        #octet_string{
            fixed  = Fixed, 
            size   = Size, 
            format = fun(Str) -> my_string:is_dec(Str) end}).

-define(ANONYMOUS_COMPOSITE(Tuple), #composite{tuple = Tuple}).

-define(VAR_C_OCTET_STRING(Size),   ?C_OCTET_STRING(false, Size)).
-define(VAR_OCTET_STRING(Size),     ?OCTET_STRING(false, Size)).
-define(FIXED_C_OCTET_STRING(Size), ?C_OCTET_STRING(true, Size)).
-define(FIXED_OCTET_STRING(Size),   ?OCTET_STRING(true, Size)).

-define(VAR_HEX_C_OCTET_STRING(Size),   ?HEX_C_OCTET_STRING(false, Size)).
-define(VAR_HEX_OCTET_STRING(Size),     ?HEX_OCTET_STRING(false, Size)).
-define(FIXED_HEX_C_OCTET_STRING(Size), ?HEX_C_OCTET_STRING(true, Size)).
-define(FIXED_HEX_OCTET_STRING(Size),   ?HEX_OCTET_STRING(true, Size)).

-define(VAR_DEC_C_OCTET_STRING(Size),   ?DEC_C_OCTET_STRING(false, Size)).
-define(VAR_DEC_OCTET_STRING(Size),     ?DEC_OCTET_STRING(false, Size)).
-define(FIXED_DEC_C_OCTET_STRING(Size), ?DEC_C_OCTET_STRING(true, Size)).
-define(FIXED_DEC_OCTET_STRING(Size),   ?DEC_OCTET_STRING(true, Size)).

-define(SIZED_LIST(Type, Size), 
        #list{type = Type, size = Size}).
</pre>
    </td>
  </tr>
</table>

<p>Time strings</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(ATIME_C_OCTET_STRING,
        #c_octet_string{
            fixed  = true, 
            size   = 17,
            format = fun(Str) -> my_string:is_atime(Str) end}).
-define(RTIME_C_OCTET_STRING,
        #c_octet_string{
            fixed  = true, 
            size   = 17,
            format = fun(Str) -> my_string:is_rtime(Str) end}).
</pre>
    </td>
  </tr>
</table>

<p>Sets</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(EMPTY,     ?UNION([])).
-define(SET(List), ?UNION(lists:map(fun(C) -&gt; ?CONSTANT(C) end, List))).
</pre>
    </td>
  </tr>
</table>


<h2><a name="param">Param Syntax</a></h2>

<p>Standard and TLV parameter syntax definition.  This layer complements
the base syntax defined in the file <b>base_syntax.hrl</b>, giving
to the parameter definitions the possibility to specify an associated error
code, a default value and a tag (on TLVs only).  A complete list of the SMPP
parameters specification is defined in <b>smpp_param.hrl</b>, based
on macros defined below and the syntax declarations included in
<b>smpp_base.hrl</b>.</p>

<p>Even this syntax is considered implementation-specific, the definitions 
herein included try to reflect the conventions used on [SMPP 5.0].</p>

<p>The following types are defined as records on the param syntax:</p>

<ol>
  <li><a href="#standard">standard</a></li>
  <li><a href="#tlv">tlv</a></li>
</ol>


<h3><a name="standard">standard</a></h3>

<p><tt>-record(standard, {name, domain, default, error})</tt>
  <ul>
    <li><tt>Name    = atom()</tt></li>
    <li><tt>Domain  = Type</tt></li>
    <li><tt>Default = term()</tt></li>
    <li><tt>Type    = constant()</tt>
           <br/><tt> | integer()</tt>
           <br/><tt> | c_octet_string()</tt>
           <br/><tt> | octet_string()</tt>
           <br/><tt> | multivalue()</tt>
           <br/><tt> | composite()</tt>
           <br/><tt> | polymorphic()</tt></li>
    <li><tt>Error  = int()</tt></li>
  </ul>
</p>

<p>Standard Parameter declaration.</p>

<dl>
  <dt>Name: </dt><dd>Name of the parameter.</dd>
  <dt>Domain: </dt><dd>Domain of the parameter.  Defined by means of the
    base syntax (<b>base_syntax.hrl</b>).
  </dd>
  <dt>Default: </dt><dd>Default value for the parameter.  Used by 
    encoding functions whenever the parameter is left undefined.
  </dd>
  <dt>Error: </dt><dd>Error code associated to the parameter.</dd>
</dl>


<h3><a name="tlv">tlv</a></h3>

<p><tt>-record(tlv, 
       {name, tag, domain, reserved, mandatory, multiple, default, error})</tt>
  <ul>
    <li><tt>Name      = atom()</tt></li>
    <li><tt>Tag       = int()</tt></li>
    <li><tt>Domain    = Type</tt></li>
    <li><tt>Type   = constant()</tt>
           <br/><tt> | integer()</tt>
           <br/><tt> | c_octet_string()</tt>
           <br/><tt> | octet_string()</tt>
           <br/><tt> | multivalue()</tt>
           <br/><tt> | composite()</tt>
           <br/><tt> | polymorphic()</tt></li>
    <li><tt>Reserved  = Type</tt></li>
    <li><tt>Mandatory = bool()</tt></li>
    <li><tt>Multiple  = bool()</tt></li>
    <li><tt>Default   = term()</tt></li>
    <li><tt>Error  = int()</tt></li>
  </ul>
</p>

<p>Tagged Length Value Parameter declaration.</p>

<dl>
  <dt>Name: </dt><dd>Name of the parameter.</dd>
  <dt>Tag: </dt><dd>Identifier of the TLV.</dd>
  <dt>Domain: </dt><dd>Domain of the parameter.  Defined by means of the
    base syntax (<b>base_syntax.hrl</b>).
  </dd>
  <dt>Reserved: </dt><dd>Set of reserved values for the parameter.  Defined by
    means of the base syntax (<b>base_syntax.hrl</b>).
  </dd>
  <dt>Mandatory: </dt><dd>Boolean.   <tt>true</tt> if the TLV is mandatory.
  </dd>
  <dt>Multiple: </dt><dd>Boolean.  <tt>true</tt> if the TLV can be encoded 
    multiple times.
  </dd>
  <dt>Default: </dt><dd>Default value for the parameter.  If the 
    encoding (or decoding) operation fails the default value should be used
    (if provided).
  </dd>
  <dt>Error: </dt><dd>Error code associated to the parameter.</dd>
</dl>


<h2><a name="parammacros">Param Syntax Macros</a></h2>

<p>Macros based on record param-types definitions.</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(STANDARD(Name, Domain, Default, Error), 
        #standard{
            name    = Name, 
            domain  = Domain, 
            default = Default, 
            error   = Error}).
-define(TLV(Name, Tag, Domain, Reserved, Mandatory, Multiple, Default, Error), 
        #tlv{
            name      = Name,
            tag       = Tag, 
            domain    = Domain,
            reserved  = Reserved, 
            mandatory = Mandatory,
            multiple  = Multiple,
            default   = Default, 
            error     = Error}).
</pre>
    </td>
  </tr>
</table>

<p>Simplified TLV Macros for Readability, some options are implicitly assigned
here.  SMPP PDU TLV definitions are more readable using these macros.</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(MANDATORY_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, true, false, Default, Error)).
-define(OPTIONAL_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, false, false, Default, Error)).
-define(MULTIPLE_MANDATORY_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, true, true, Default, Error)).
-define(MULTIPLE_OPTIONAL_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, false, true, Default, Error)).
</pre>
    </td>
  </tr>
</table>


<h2><a name="pdu">PDU Syntax</a></h2>

<p>This syntax extends the <i>param syntax</i> and gives support to PDU
defintions.</p>

<p>The following types are defined as records on the pdu syntax:</p>

<ol>
  <li><a href="#pdu">pdu</a></li>
</ol>


<h3><a name="pdu">pdu</a></h3>

<p><tt>-record(pdu, {command_id, stds_types, tlvs_types})</tt>
  <ul>
    <li><tt>CommandId = int()</tt></li>
    <li><tt>StdsTypes = [standard()]</tt></li>
    <li><tt>TlvsTypes = [tlv()]</tt></li>
  </ul>
</p>

<p>PDU definitions.</p>

<dl>
  <dt>CommandId: </dt><dd>SMPP <i>command_id</i>.</dd>
  <dt>StdsTypes: </dt><dd>List with the types of the standard parameters.
    There is one descriptor per standard parameter on the PDU.  This list
    must have the same exact order than the one defined on the SMPP protocol
    specification.
  </dd>
  <dt>TlvsTypes: </dt><dd>List with the types of every permitted TLV of the
    PDU.  The SMPP protocol specification does not establish any kind of
    ordering for the TLV parameters.  The order on this list might only be
    relevant from an efficiency point of view, refer to the 
    <a href="pdu_syntax.html#pack-3">packing</a>/
    <a href="pdu_syntax.html#unpack-3">unpacking</a> functions 
    implementation on <a href="pdu_syntax.html">pdu_syntax.erl</a>.
  </dd>
</dl>


<h2><a name="pdumacros">PDU Syntax Macros</a></h2>

<p>Macros based on PDU record definition.</p>

<table bgcolor="#CCCCCC" width="100%" border="1">
  <tr>
    <td>
<pre>
-define(PDU(CommandId, StdsTypes, TlvsTypes),
        #pdu{command_id = CommandId,
             stds_types = StdsTypes, 
             tlvs_types = TlvsTypes}).
</pre>
    </td>
  </tr>
</table>


<h2><a name="pics">PICS Proforma</a></h2>

Find OSERL's PICS proforma in openoffice format 
<a href="oserl_pics.sxw">here</a>.


<h2><a name="changes">Changes</a></h2>

<p>See changes log <a href="changes.html">here</a>.</p>


<h2><a name="contributors">Contributors</a></h2>

<ul>
  <li>Miguel Rodriguez Rubinos</li>
  <li>Heinrich Venter</li>
</ul>


<h2><a name="thanks">Special Thanks</a></h2>

<p>Thanks to all who have helped me out with their feedback, very specially to 
those who have even <a href="#contributors">contributed</a> with code.</p>

<p>Thanks also to those who reported bugs and suggested improvements, in
this term, I'd like to also explicitly thank Anders Nygren.</p>


<h2><a name="todo">TODO</a></h2>

<ul>
  <li>Version 1.2
    <ol>
      <li><a href="gen_esme_session.html">gen_esme_session</a> and
        <a href="gen_smsc_session.html">gen_smsc_session</a> are almost
        identical.

        <p>Implement a <i>gen_session</i> to hold code common to 
        <a href="gen_esme_session.html">gen_esme_session</a> and
        <a href="gen_smsc_session.html">gen_smsc_session</a>.</p>
      </li>
      <li><a href="gen_esme.html">gen_esme</a> and
        <a href="gen_smsc.html">gen_smsc</a> are almost
        identical.

        <p>Implement a <i>gen_peer</i> to hold code common to 
        <a href="gen_esme.html">gen_esme</a> and 
        <a href="gen_smsc.html">gen_smsc</a>.</p>
      </li>
    </ol>
  </li>
</ul>


<h2><a name="references">References</a></h2>

<dl>
  <dt>[SMPP 5.0]</dt><dd>Short Message Peer-to-Peer Protocol Specification.
    Version 5.0. SMS Forum.
  </dd>
</dl>
