
	OSERL overview page

@author Enrique Marcote Peña <mpquique@users.sourceforge.net> [http://www.des.udc.es/~mpquique/]
@copyright 2003 - 2004 Enrique Marcote Peña
@version 0.2 alpha

@doc OSERL is an Erlang implementation of the Short Message Peer to Peer 
Protocol version 5.0.

<p>As a guideline, some comments include references to the specific section
numbers on [SMPP 5.0].</p>


<h2><a name="contents">Contents</a></h2>
<ol>
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#overview">SMPP protocol implementation overview</a></li>
  <li><a href="#install">Install OSERL</a></li>
  <li><a href="#howto">Developing SMS based applications with OSERL</a>
    <ol>
      <li><a href="#howto_esme">How to implement an ESME</a>
        <ol>
          <li><a href="#submit">Submit SM sample (java vs. erlang)</a></li>
          <li><a href="#echo">Sample echo ESME</a></li>
          <li><a href="#code_lock">Code lock ESME example</a></li>
        </ol> 
      </li>
      <li><a href="#howto_mc">How to implement a MC</a></li>
      <li><a href="#tune">Fine tune OSERL's SMPP implementation</a>
        <ol>
          <li><a href="#smpp_pdu">smpp_pdu.hrl</a></li>
          <li><a href="#smpp_param">smpp_param.hrl</a></li>
          <li><a href="#smpp_base">smpp_base.hrl</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#storage">PDU data storage</a></li>
  <li><a href="#translation">Translating the SMPP specification</a></li>
  <li><a href="#base">Base Syntax</a></li>
  <li><a href="#basemacros">Base Syntax Macros</a></li>
  <li><a href="#param">Param Syntax</a></li>
  <li><a href="#parammacros">Param Syntax Macros</a></li>
  <li><a href="#pdu">PDU Syntax</a></li>
  <li><a href="#pdumacros">PDU Syntax Macros</a></li>
  <li><a href="#behaviours">Behaviours</a></li>
  <li><a href="#pics">PICS Proforma</a></li>
  <li><a href="#changes">Changes</a>
    <ol>
      <li><a href="#changes0_1-0_2">Changes 0.1 -&gt; 0.2</a></li>
    </ol>
  </li>
  <li><a href="#todo">TODO</a></li>
  <li><a href="#references">References</a></li>
</ol>


<h2><a name="intro">Introduction</a></h2>

<p>Short Message Peer to Peer (SMPP) protocol [SMPP 5.0] is an open, 
industry standard designed to provide a flexible data communications interface 
for the transfer of short message data between External Short Message Entities 
(ESME), Routing Entities (RE) and Message Centers (MC).</p>

<p>A great amount of the effort required for the development of any of the 
above mention entities is generally spent on a partial implementation of the 
SMPP protocol.  It is rare to find an implementation that covers every aspect 
of the SMPP protocol as OSERL does.</p>

<p>OSERL (open SMPP erlang library) comprises the <i>entire specification</i> 
of the recently released SMPP version 5.0 (February 20th, 2003).  Moreover, 
every forward and backward compatibility guidelines were adopted at the design 
stage, what makes the resulting library easy to maintain and update to any
future or previous version of the protocol.</p>


<h2><a name="overview">SMPP protocol implementation overview</a></h2>

<p>The SMPP protocol defines a set of operations, each one taking the form of
a request and response PDU (Protocol Data Unit).</p>

<p>The first challenge to face on the implementation was to develop packing 
and unpacking functions for the command PDUs.  The approach was to translate 
the entire SMPP protocol specification to erlang terms using the syntax 
notation described next.  Then, we only needed to create the encoding and 
decoding functions for the primitive types used on our notation, and the whole 
problem of the SMPP PDU packing/unpacking was solved.</p>

<p>Notice that whenever a new version of the SMPP protocol gets released, 
we'll just need to update our "static" translation of the protocol to get 
support for new parameters and PDUs.  Packing and unpacking functions
won't need to be modified.</p>

<p>Besides the PDU format, encoding (decoding) mechanisms and associated error 
codes, the SMPP protocol specification defines how a well behaved SMPP based 
application should be implemented.  Even the behaviour of every ESME (RE or MC)
is predefined by the protocol specification in many senses, nowadays every 
developer must program these dynamic aspects of the protocol on its own.  
OSERL provides a <a href="#behaviours">generic ESME</a>  implementation that 
transparently handles just about every feature of the SMPP protocol that 
leaves room for automation, and there are many of them, as we will see 
<a href="#behaviours">later on</a>.</p>

<p>SMPP version 5.0 declares 31 PDUs for 19 operations.  All SMPP PDUs 
comprise of organized set of parameters.  Those parameters are defined by 
means of a primitive type:  <i>Integer</i>, <i>C-Octet String</i> and 
<i>Octet String</i>.  As well as the primitive type, every parameter has a 
<i>name</i>, a <i>domain</i> (set of permitted values of the primitive 
type) and optionally an associated <i>error code</i>.  Furthermore, there is a 
kind of parameters called TLVs (Tagged Length Value), whose definition also 
involves a <i>tag</i> (identifier), a set of <i>reserved values</i> (of the 
primitive type) and sometimes, a <i>default value</i>.</p>

<p>We divided the syntax notation into three layers; <a href="#base">base 
syntax</a>, <a href="#param">param syntax</a> and <a href="#pdu">PDU syntax</a>
layer.  The first one is used to define the erlang data structures for the 
representation of the SMPP primitive types, domains and reserved values.  The 
parameter syntax provides an erlang notation to complete the field  definitions
(we'll use field and parameter interchangeable), adding to the primitive 
types of the underlying layer: parameter names, error codes and default values.
On top of the parameter syntax, a PDU syntax was built, this upper layer 
defines the structure for a PDU descriptor.</p>

<p>Each syntax layer has its own encoding and decoding functions.  The PDU 
packing function relies on the parameter encoder to translate to binary format 
every individual field of a PDU.  In the same way, the parameter syntax layer 
doesn't know how encode a primitive value and again, must rely on the base 
syntax encoder to do the work.  The same process applies  for the unpacking 
mechanism.</p>

<table width="100%" border="0" cellpadding="0">
  <tr> 
    <td width="70%" valign="top" align="center">
      <table width="100%" border="1" cellpadding="2">
        <tr> 
          <th colspan="2" valign="middle" align="center">operation</th>
        </tr>
        <tr> 
          <th valign="middle" align="center">PDU datatypes</th>
          <th valign="middle" align="center">PDU pack/unpack</th>
        </tr>
        <tr> 
          <th valign="middle" align="center">Param datatypes</th>
          <th valign="middle" align="center">Param encoding/decoding</th>
        </tr>
        <tr> 
          <th valign="middle" align="center">Base datatypes</th>
          <th valign="middle" align="center">Base encoding/decoding</th>
        </tr>
      </table>
    </td>
    <td width="30%" valign="top" align="center">
      <table width="100%" border="0" cellpadding="3">
        <tr> 
          <th align="left">&#160;</th>
        </tr>
        <tr> 
          <th align="left">PDU syntax</th>
        </tr>
        <tr> 
          <th align="left">Param syntax</th>
        </tr>
        <tr> 
          <th align="left">Base syntax</th>
        </tr>
      </table>
    </td>
  </tr>
</table>

<p>On this table we find the SMPP <a href="operation.html">operation</a> 
module on top of the PDU syntax.  This module hides the type descriptors of 
the SMPP specification to higher layers.</p>


<h2><a name="install">Install OSERL</a></h2>

Install common_lib package:

<pre>
  tar -zxvf common_lib-0.1.tar.gz
  cd common_lib-0.1
  make
</pre>

<p>Install oserl package:
</p>

<pre>
  tar -zxvf oserl-0.1.tar.gz
  cd oserl-0.1
  make
</pre>

<p>Put the ebin directory of both packages in your code path.
</p>
<p>To compile an erlang program using oserl, don't forget to add a reference to
the include directory:
</p>

<pre>
   -I &lt;path-to-oserl&gt;/include -pz &lt;path-to-oserl&gt;/ebin
</pre>


<h2><a name="howto">Developing SMS based applications with OSERL</a></h2>

This sections shows how to implement SMS based applications with the
Open SMPP Erlang Library. 

<p>Even if you don't have any prior experience with it, I strongly recommend 
you considering erlang as the programming language for the development of 
your ESME/MC or RE.</p>

<p>If you are reluctant to experience with a new (better ;-) development 
environment, you may want to consider using OSERL anyway.  Erlang has 
<a href="http://www.erlang.org/doc/r9c/doc/tutorial/part_frame.html">mechanisms
to talk to other languages</a> such us C or java.</p>

<p>Examples below only apply to erlang development.</p>


<h3><a name="howto_esme">How to implement an ESME</a></h3>

This is a long read.  Hope the examples I've include here complement the rest 
of the documentation (I realize there was a lack of code samples on it).

<p>I assume you have OSERL installed and you are already familiar with 
<a href="http://www.erlang.org/doc/r9c/doc/design_principles/part_frame.html">
OTP behaviors</a>.  Should you encounter any problems installing OSERL, please 
let me know.</p>

<p>To implement an ESME I recommend using the <a href="gen_esme.html">gen_esme
</a> behavior.  This is a custom behavior (provided within OSERL), which 
automatically handles many of the cumbersome details associated to an ESME 
implementation.  If you use this behavior you won't need to care about SMPP 
timers, PDU sequencing, link enquires, PDU encoding/decoding, error checking, 
error responses, recovering/reconnection strategies  and so forth.  The 
<a href="gen_esme.html">gen_esme behavior</a> takes care of these things 
for you.</p>

<p>Let us see how the whole thing works by example.  First, we'll examine the
<a href="examples/echo_esme.erl">echo_esme.erl</a> example.  Next we'll find 
out how to implement a more complex ESME.</p>


<h4><a name="submit">Submit SM sample (java vs. erlang)</a></h4>

<p>If you are a SMPP developer, you will be familiar with java or C SMPP APIs, 
and wondering how does an equivalent erlang code to a given java example, 
looks like.  Such a comparison is shown in <a href="examples/submit_esme.erl">
doc/examples/submit_esme.erl</a>, where a <i>submit_sm</i> java code is
directly translated into erlang, using OSERL.</p>

<p>The original java sample had too many I/O instructions, since these kind of
instructions are pretty much the same in any language, you'll find both
implementations very similar.  I believe this <i>submit_sm</i> example 
doesn't show the real strength of a SMPP erlang implementation.  To find out 
the advantages of OSERL, I encourage you to implement the ESME examples below 
(<a href="#echo">echo_esme</a> and <a href="#code_lock">code_lock_esme</a>) in 
a language such us java, and compare the result with the erlang implementations
given below (I think you'll find erlang implementation much more readable and 
compact).</p>

<table width="100%" border="1">
  <tr>
    <th width="50%" align="center">java submit_sm</th>
    <th width="50%" align="center">erlang submit_sm</th>
  </tr>
  <tr>
    <td width="50%" valign="top">
<pre>
public String  submit(String mobileNumber, String userMessage) {
    SubmitSM request = new SubmitSM();
    SubmitSMResp response;
  
    // input values
    serviceType = getParam("Service type", serviceType);
    sourceAddress = getAddress("Source",sourceAddress);
    destAddress = getAddress("Destination",new Address(mobileNumber));
    replaceIfPresentFlag = getParam("Replace if present flag", 
                                     replaceIfPresentFlag);
    shortMessage = userMessage;
    scheduleDeliveryTime = getParam("Schedule delivery time", 
                                    scheduleDeliveryTime);
    validityPeriod = getParam("Validity period", validityPeriod);
    esmClass = getParam("Esm class", esmClass);
    protocolId = 0;
    priorityFlag = getParam("Priority flag", priorityFlag);
    registeredDelivery = getParam("Registered delivery", 
                                   registeredDelivery);
    dataCoding = 0x10; // For Flash Message
    smDefaultMsgId = getParam("Sm default msg id", smDefaultMsgId);

    // set values
    request.setServiceType(serviceType);
    request.setSourceAddr(sourceAddress);
    request.setDestAddr(destAddress);
    request.setReplaceIfPresentFlag(replaceIfPresentFlag);
    request.setShortMessage(shortMessage);
    request.setScheduleDeliveryTime(scheduleDeliveryTime);
    request.setValidityPeriod(validityPeriod);
    request.setEsmClass(esmClass);
    request.setProtocolId(protocolId);
    request.setPriorityFlag(priorityFlag);
    request.setRegisteredDelivery(registeredDelivery);
    request.setDataCoding(dataCoding);
    request.setSmDefaultMsgId(smDefaultMsgId);

    // send the request
    int count = 1;
    System.out.println();
    count = getParam("How many times to submit this message (load test)",
                     count);
    for (int i = 0; i&lt;count; i++) {
        request.assignSequenceNumber(true);
        //System.out.print("#"+i+"  ");
        System.out.println("Submit request " + request.debugString());
        if (asynchronous) {
            //session.submit(request);  
            response = session.submit(request);
            messageId = response.getMessageId();
            //System.out.println();
            return messageId;
        } else {
            response = session.submit(request);                    
            messageId = response.getMessageId();
            System.out.println("Submit response " + 
                               response.debugString() + 
                               " MESSAGE ID : " + 
                               messageId);
            return messageId;
        }
    }   
    return messageId;            
}
</pre>
    </td>
    <td width="50%" valign="top">
<pre>
submit_sm(MobileNumber, UserMessage) ->



    % input values
    ServiceType = read_string("Service type> "),
    SourceAddress = read_string("Source> "),

    ReplaceIfPresentFlag = read_decimal("Replace if present flag> "),


    ScheduleDeliveryTime = read_string("Schedule delivery time> "),

    ValidityPeriod = read_string("Validity period> "),
    EsmClass = read_decimal("Esm class> "),
    ProtocolId = 0,
    PriorityFlag = read_decimal("Priority flag> "),
    RegisteredDelivery = read_decimal("Registered delivery> "),

    DataCoding = 2#10,  % For Flash Message
    SmDefaultMsgId = read_decimal("Sm default msg id> "),

    % set values (create the ParamList)
    ParamList = [{service_type, ServiceType},
                 {source_addr, SourceAddress},
                 {destination_addr, MobileNumber},
                 {replace_if_present_flag, ReplaceIfPresentFlag},
                 {short_message, UserMessage},
                 {schedule_delivery_time, ScheduleDeliveryTime},
                 {validity_period, ValidityPeriod},
                 {esm_class, EsmClass},
                 {protocol_id, ProtocolId},
                 {priority_flag, PriorityFlag},
                 {registered_delivery, RegisteredDelivery},
                 {data_coding, DataCoding},
                 {sm_default_msg_id, SmDefaultMsgId}],

    % send the request
    case read_decimal("How many times to submit this message (load test)") of
        Count when integer(Count) -> submit_sm_async_iter(ParamList, Count);
        _Error                    -> submit_sm_async_iter(ParamList, 1)
    end.


submit_sm_async_iter(ParamList, 0) -> 
    ok;
submit_sm_async_iter(ParamList, Count) ->
    spawn(fun() -> submit_sm(ParamList) end),
    submit_sm_async_iter(ParamList, Count - 1).


submit_sm(ParamList) -> 
    case gen_esme:submit_sm(?ESME_NAME, ParamList) of
        {ok, Response} -> 
            % See how to get a parameter value
            MessageId = operation:get_param(message_id, Response),
            io:format("Message ID: ~p~n", [MessageId]);
        {error, Error} ->
            io:format("Submit operation failed with ~p~n", [Error])
    end.
</pre>
    </td>
  </tr>
</table>

<p><a href="submit_esme.html">submit_esme</a> is not just an erlang 
<i>submit_sm</i> function, but a complete ESME implementation.  This ESME
binds as a transmitter, behaves asynchronously, controls congestion and 
connection failures, and transparently handles SMPP timers and other
aspects defined in the SMPP protocol.</p>

<p>Get into doc/examples directory and compile the <a href="submit_esme.html">
submit_esme</a> example by</p>

<pre>
    $ erlc -W -I ../../include -pz ../../ebin submit_esme.erl
</pre>

<p>Now, open an erlang shell and test it:</p>

<pre>
    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; executing user profile in HOME/.erlang
    .erlang rc finished
</pre>

<p>Assuming you've untared the <i>common_lib</i> in the same subdirectory
than <i>oserl</i>.</p>

<pre>
    1&gt; code:add_path("../../../common_lib/ebin").
    true
    2&gt; code:add_path("../../ebin").
    true
</pre>

<p>and finally do</p>

<pre>
    3&gt; submit_esme:start().
    {ok,&lt;0.21.0&gt;}
    4&gt;  submit_esme:submit_sm("123456789", "hello there").
    "Service type> "CMT
    "Source> "1959
    "Replace if present flag> "0
    "Schedule delivery time> "040207105523000+
    "Validity period> "040208105523000+
    "Esm class> "0
    "Priority flag> "0
    "Registered delivery> "0
    "Sm default msg id> "0
    "How many times to submit this message (load test)"5
    ok
    Message ID: "34800629"
    Message ID: "24512469"
    Message ID: "49646623"
    Message ID: "34236909"
    Message ID: "64973652"
    4&gt; submit_esme:stop().
    ok
</pre>

<p>To test your applications you may use the <a href="http://www.mobilelandscape.co.uk">SMPPSim SMSC simulator by logica</a>.  We usually have this SMSC 
simulator running on 193.144.50.51 (which is the default IP address used by 
<a href="submit_esme.html#start-0">start/0</a>), so starting the submit ESME as
shown above should work for you also (if you have internet access).   You may 
use this machine for your tests, although be aware we use that box for testing 
just about everything over here, so it might not work properly.  You may 
install SMPPSim on your own system, then you will have access to the SMSC 
log also, which I find very helpful.  You can download SMPPSim from 
<a href="http://www.mobilelandscape.co.uk/">http://www.mobilelandscape.co.uk
</a></p>


<h4><a name="echo">Sample echo ESME</a></h4>

<a href="echo_esme.html">echo_esme</a> offers a very simple (and useless) 
service to subscribers.  Whenever a client sends a Short Message to this 
service, the ESME responds sending back the exact same Short Message.

<p>You may find this example under <a href="examples/echo_esme.erl">
doc/examples/echo_esme.erl</a>.</p>

<p>Get into doc/examples directory compile and test this new example:</p>

<pre>
    $ erlc -W -I ../../include -pz ../../ebin echo_esme.erl

    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; executing user profile in HOME/.erlang
    .erlang rc finished
    1&gt; code:add_path("../../../common_lib/ebin").
    true
    2&gt; code:add_path("../../ebin").
    true
    3&gt; echo_esme:start().
    Bound as transmitter to "SMPPSim"
    {ok,&lt;0.41.0&gt;}
    Bound as receiver to "SMPPSim"
</pre>

<p>To test the next two examples using the SMSC simulator mentioned in the
<a href="submit_esme.html">submit_esme</a> example, you may use 
<a href="examples/send_oserl.html">this HTML form</a>, and try sending short 
messages to your test ESMEs.</p>

<p>Notice the address of the echo service is <i>1948</i> by default.  If you 
decide to start the ESME in another address, you will need to change the 
destination address in the HTML form (this is a good idea if you're planning 
to use the online SMSC testing simulator above mentioned, other users doing 
their online tests might be using the same ESME address, so it'll be wise to 
change it).  Of course, if you are running the SMPPSim SMSC simulator on your 
own machine (recommended), you will need to update the IP address in the HTML 
form instead (to point it to your SMSC).</p>

<p>Type the message "hello" in the HTML form and click the 
button &lt;send&gt;.  You won't get the echo response back in your browser 
phone, or whatever it looks like :-).  SMPPSim SMSC simulator doesn't support 
that, this tool just listens on a HTTP port, but cannot send SM responses back.
Anyway, you should see the following message in your browser:</p>

<pre>
    DELIVER_SM invoked OK
</pre>

<p>This means the message was successfully forwarded to your ESME.  We can 
confirm that looking on the erlang shell, where the following message should be
displayed:</p>

<pre>
    Echoing SM: {short_message,"hello"}
</pre>

<p>Let's give it another try (send another message with text "bye" and stop
the ESME).</p>

<pre>
    Echoing SM: {short_message,"bye"}
    4&gt; echo_esme:stop().
    Unbound as receiver.
    Unbound as transmitter.
    ok
</pre>

<p>During this session, the log of the SMSC simulator shows something like:</p>

<pre>
2004.02.07 11:25:43 668 INFO    CH8: BIND_RECEIVER:
2004.02.07 11:25:43 668 INFO    Hex dump (39) bytes:
2004.02.07 11:25:43 668 INFO    00000027:00000001:00000000:00000001:
2004.02.07 11:25:43 668 INFO    62616E61:6E610073:65637265:74000050:
2004.02.07 11:25:43 669 INFO    01013139:343800
2004.02.07 11:25:43 669 INFO
2004.02.07 11:25:43 670 INFO    SMPPReceiver: setting address range to 1948
2004.02.07 11:25:43 670 INFO    CH8: BIND_RECEIVER_RESP:
2004.02.07 11:25:43 671 INFO    Hex dump (24) bytes:
2004.02.07 11:25:43 671 INFO    00000018:80000001:00000000:00000001:
2004.02.07 11:25:43 671 INFO    534D5050:53696D00:
2004.02.07 11:25:43 671 INFO
2004.02.07 11:25:43 671 INFO    1 receivers connected and bound
2004.02.07 11:25:43 674 INFO    ConnectionHandler CH9 accepted a connection
2004.02.07 11:25:43 677 INFO    CH9: BIND_TRANSMITTER:
2004.02.07 11:25:43 677 INFO    Hex dump (39) bytes:
2004.02.07 11:25:43 677 INFO    00000027:00000002:00000000:00000001:
2004.02.07 11:25:43 677 INFO    62616E61:6E610073:65637265:74000050:
2004.02.07 11:25:43 677 INFO    01013139:343800
2004.02.07 11:25:43 677 INFO
2004.02.07 11:25:43 678 INFO    CH9: BIND_TRANSMITTER_RESP:
2004.02.07 11:25:43 678 INFO    Hex dump (24) bytes:
2004.02.07 11:25:43 678 INFO    00000018:80000002:00000000:00000001:
2004.02.07 11:25:43 678 INFO    534D5050:53696D00:
2004.02.07 11:25:43 678 INFO
2004.02.07 11:25:49 022 INFO    HC0 accepted connection
2004.02.07 11:25:49 023 INFO    HC0: DELIVER_SM
2004.02.07 11:25:49 024 INFO    DELIVER_SM:
2004.02.07 11:25:49 024 INFO    Hex dump (51) bytes:
2004.02.07 11:25:49 024 INFO    00000033:00000005:00000000:00000006:
2004.02.07 11:25:49 024 INFO    00000031:32333435:36373839:00000031:
2004.02.07 11:25:49 024 INFO    39343800:00000000:00000000:00056865:
2004.02.07 11:25:49 024 INFO    6C6C6F
2004.02.07 11:25:49 025 INFO
2004.02.07 11:25:49 025 INFO    HTTPController HC0 waiting for connection
2004.02.07 11:25:49 030 INFO    CH8: DELIVER_SM_RESP:
2004.02.07 11:25:49 030 INFO    Hex dump (27) bytes:
2004.02.07 11:25:49 030 INFO    0000001B:80000005:00000000:00000006:
2004.02.07 11:25:49 030 INFO    00001D00:01000428:000100
2004.02.07 11:25:49 030 INFO
2004.02.07 11:25:49 035 INFO    CH9: SUBMIT_SM:
2004.02.07 11:25:49 035 INFO    Hex dump (117) bytes:
2004.02.07 11:25:49 035 INFO    00000075:00000004:00000000:00000002:
2004.02.07 11:25:49 035 INFO    00010131:39343800:00003132:33343536:
2004.02.07 11:25:49 035 INFO    37383900:00000000:00000003:00056865:
2004.02.07 11:25:49 035 INFO    6C6C6F00:05000100:00070001:01000600:
2004.02.07 11:25:49 035 INFO    01010008:00020000:04240000:00190001:
2004.02.07 11:25:49 035 INFO    00020F00:0101020E:00010104:21000101:
2004.02.07 11:25:49 035 INFO    000D0001:00000F00:0101000E:00010100:
2004.02.07 11:25:49 035 INFO    10000200:00
2004.02.07 11:25:49 035 INFO
2004.02.07 11:25:49 036 INFO    CH9:SUBMIT_SM_RESP:
2004.02.07 11:25:49 036 INFO    Hex dump (25) bytes:
2004.02.07 11:25:49 036 INFO    00000019:80000004:00000000:00000002:
2004.02.07 11:25:49 037 INFO    37353333:33373232:00
2004.02.07 11:25:49 037 INFO
2004.02.07 11:25:56 460 INFO    HC0 accepted connection
2004.02.07 11:25:56 461 INFO    HC0: DELIVER_SM
2004.02.07 11:25:56 463 INFO    DELIVER_SM:
2004.02.07 11:25:56 464 INFO    Hex dump (49) bytes:
2004.02.07 11:25:56 464 INFO    00000031:00000005:00000000:00000007:
2004.02.07 11:25:56 464 INFO    00000031:32333435:36373839:00000031:
2004.02.07 11:25:56 464 INFO    39343800:00000000:00000000:00036279:
2004.02.07 11:25:56 464 INFO    65
2004.02.07 11:25:56 464 INFO
2004.02.07 11:25:56 464 INFO    HTTPController HC0 waiting for connection
2004.02.07 11:25:56 468 INFO    CH8: DELIVER_SM_RESP:
2004.02.07 11:25:56 468 INFO    Hex dump (27) bytes:
2004.02.07 11:25:56 468 INFO    0000001B:80000005:00000000:00000007:
2004.02.07 11:25:56 468 INFO    00001D00:01000428:000100
2004.02.07 11:25:56 468 INFO
2004.02.07 11:25:56 469 INFO    CH9: SUBMIT_SM:
2004.02.07 11:25:56 469 INFO    Hex dump (115) bytes:
2004.02.07 11:25:56 469 INFO    00000073:00000004:00000000:00000003:
2004.02.07 11:25:56 469 INFO    00010131:39343800:00003132:33343536:
2004.02.07 11:25:56 469 INFO    37383900:00000000:00000003:00036279:
2004.02.07 11:25:56 469 INFO    65000500:01000007:00010100:06000101:
2004.02.07 11:25:56 470 INFO    00080002:00000424:00000019:00010002:
2004.02.07 11:25:56 470 INFO    0F000101:020E0001:01042100:0101000D:
2004.02.07 11:25:56 470 INFO    00010000:0F000101:000E0001:01001000:
2004.02.07 11:25:56 470 INFO    020000
2004.02.07 11:25:56 470 INFO
2004.02.07 11:25:56 471 INFO    CH9:SUBMIT_SM_RESP:
2004.02.07 11:25:56 471 INFO    Hex dump (25) bytes:
2004.02.07 11:25:56 471 INFO    00000019:80000004:00000000:00000003:
2004.02.07 11:25:56 471 INFO    36363137:36343538:00
2004.02.07 11:25:56 471 INFO
2004.02.07 11:26:07 273 INFO    CH8: UNBIND
2004.02.07 11:26:07 273 INFO    Hex dump (16) bytes:
2004.02.07 11:26:07 273 INFO    00000010:00000006:00000000:00000002:
2004.02.07 11:26:07 273 INFO
2004.02.07 11:26:07 273 INFO
2004.02.07 11:26:07 275 INFO    0 receivers connected and bound
2004.02.07 11:26:07 277 INFO    CH8: UNBIND_RESP
2004.02.07 11:26:07 277 INFO    Hex dump (16) bytes:
2004.02.07 11:26:07 277 INFO    00000010:80000006:00000000:00000002:
2004.02.07 11:26:07 277 INFO
2004.02.07 11:26:07 277 INFO
2004.02.07 11:26:07 277 INFO    CH8 closing connection
2004.02.07 11:26:07 277 INFO    ConnectionHandler CH8 waiting for connection
2004.02.07 11:26:07 280 INFO    CH9: UNBIND
2004.02.07 11:26:07 280 INFO    Hex dump (16) bytes:
2004.02.07 11:26:07 281 INFO    00000010:00000006:00000000:00000004:
2004.02.07 11:26:07 281 INFO
2004.02.07 11:26:07 281 INFO
2004.02.07 11:26:07 281 INFO    CH9: UNBIND_RESP
2004.02.07 11:26:07 281 INFO    Hex dump (16) bytes:
2004.02.07 11:26:07 281 INFO    00000010:80000006:00000000:00000004:
2004.02.07 11:26:07 281 INFO
2004.02.07 11:26:07 281 INFO
2004.02.07 11:26:07 281 INFO    CH9 closing connection
2004.02.07 11:26:07 281 INFO    ConnectionHandler CH9 waiting for connection
</pre>

<p>Now that we have our ESME stopped, and unbound from the SMSC simulator, if
you try to send another message through your browser, you'll get:</p>

<pre>
    No receiver available to deliver messageHTTP/1.1 200

    DELIVER_SM invoked OK
</pre>

<p>Let's dig into the details of the echo ESME implementation.</p>

<p>If you look at the documentation for the <a href="gen_esme.html">gen_esme
</a> behavior, you will find all the exported functions and callbacks available
on this behavior.  Notice there is an exported function for every SMPP 
operation an ESME may issue.  Among others, these functions are exported:</p>

<ul>
  <li>alert_notification</li>
  <li>bind_receiver</li>
  <li>bind_transceiver</li>
  <li>bind_transmitter</li>
  <li>broadcast_sm</li>
  <li>cancel_broadcast_sm</li>
  <li>cancel_sm</li>
  <li>data_sm</li>
  <li>query_broadcast_sm</li>
  <li>query_sm</li>
  <li>replace_sm</li>
  <li>submit_multi</li>
  <li>submit_sm</li>
  <li>unbind_receiver</li>
  <li>unbind_transceiver</li>
  <li>unbind_transmitter</li>
</ul>

<p>As we mention, there are some other functions, most of them need to be 
exported to implement the <a href="gen_esme_session.html">gen_esme_session</a> 
behavior (notice that <a href="gen_esme.html">gen_esme</a> behavior is 
implemented on top of the <a href="gen_esme_session.html">gen_esme_session</a> 
behavior, which in turn was built on top of the <a href="gen_connection.html">
gen_connection</a> behavior).  Let us ignore the rest of the exported 
functions at this moment.</p>

<p>Recall <a href="gen_esme.html#submit_sm-2">gen_esme:submit_sm/2</a> function
and how it was used in our <a href="echo_esme.html">echo_esme</a> example.</p>

<pre>
deliver_sm(_Pid, Eid, Pdu) -&gt;
    Mesg = sm:message_user_data(Pdu),   % gets incoming short message
    Dest = sm:reply_address(Pdu),       % source address as response address
    io:format("Echoing SM: ~p~n", [Mesg]),
    spawn(fun() -&gt; gen_esme:submit_sm(Eid, [Mesg|Dest]) end), 
    {ok, []}.
</pre>

<p>See how we submit a short message from our ESME.  Just need to call
<a href="gen_esme.html#submit_sm-2">gen_esme:submit_sm/2</a>.  This function 
is declared as follows:</p>

<p><tt>submit_sm(Eid::Eid, ParamList::ParamList) -&gt; Result</tt>
</p>

<ul>
  <li>Eid = pid()</li>
  <li>ParamList = [{ParamName, ParamValue}]</li>
  <li>ParamName = atom()</li>
  <li>ParamValue = term()</li>
  <li>Result = {ok, PduResp} | {error, Error}</li>
  <li>PduResp = pdu()</li>
  <li>Error = {error_code, int()} | atom()</li>
</ul>

<p>The first argument is the <tt>pid()</tt> (or name) of our ESME; most of 
OTP behaviors need this argument on their functions.  The second 
argument (<tt>ParamList</tt>) holds the parameter values we are going to send 
along in our PDU.  This argument is an assoc list; the items on this list are 
pairs in the format <tt>{ParamName, ParamValue}</tt>.
</p>

<p>Let me rewrite the code above without using the <a href="sm.html">sm</a> 
module, so you can see all the details:
</p>

<pre>
deliver_sm(_Pid, Eid, Pdu) -&gt;
    % First of all, lets get the source address.

    SourceAddrTon = operation:get_param(source_addr_ton, Pdu),
    SourceAddrNpi = operation:get_param(source_addr_npi, Pdu),
    SourceAddr    = operation:get_param(source_addr,     Pdu),

    % Get the message payload from the incoming PDU. 
    % Since we don't know if the SMSC sends the short message using the
    % short_message or the message_payload parameter, we have to look which
    % one is used.
    %
    %  We'd also want to respond using the same parameter the SMSC uses.

    MessageUserData = 
        case operation:get_param(short_message, Pdu) of
            ShortMessage when ShortMessage == ""; ShortMessage == undefined -&gt;
                {message_payload, operation:get_param(message_payload, Pdu)};
            ShortMessage -&gt;
                {short_message, ShortMessage}
        end,

    % Now we're ready to create the parameter list for our response

    ResponseAddr = [{dest_addr_ton,    SourceAddrTon},
                    {dest_addr_npi,    SourceAddrNpi},
                    {destination_addr, SourceAddr}],

    ParamList = [MessageUserData|ResponseAddr],

    io:format("Echoing SM: ~p~n", [MessageUserData]),

    spawn(fun() -&gt; gen_esme:submit_sm(Eid, ParamList) end), 
    {ok, []}.
</pre>

<p>Since getting the <i>message_payload</i> and creating the response address 
from the source address are common operations, both have been implemented in 
<a href="sm.html">sm.erl</a> module by the functions 
<a href="sm.html#message_user_data-1">sm:message_user_data/1</a> and 
<a href="sm.html#reply_address-1">sm:reply_address/1</a> respectively.</p>

<p><a href="gen_esme.htmlsubmit_sm-2">gen_esme:submit_sm/2</a> creates a 
<i>submit_sm</i> PDU using the values in the parameter list.  For those 
parameters not defined in the parameter list, the default value is used. 
Default values for every parameter are defined in 
<a href="../../include/smpp_param.hrl">smpp_param.hrl</a>.  Values in 
<tt>ParamList</tt> override defaults.</p>

<p>Parameter names and types are those in the SMPP specification, should you 
find any problems assigning values to an specific parameter, check their exact
names and types in <a href="../../include/smpp_param.hrl">smpp_param.hrl</a>.
</p>

<p>SMPP composite parameters were defined as records.  For example, values for 
<i>unsuccess_sme</i> parameters must be defined by means of the 
<tt>unsuccess_sme</tt> record (defined in 
<a href="../../include/smpp_base.hrl">smpp_base.hrl</a>).</p>

<pre>
%%%
% %@spec {unsuccess_sme,
%         DestAddrTon,
%         DestAddrNpi,
%         DestinationAddr,
%         ErrorStatusCode}
%    DestAddrTon     = int()
%    DestAddrNpi     = int()
%    DestinationAddr = string()
%    ErrorStatusCode = int()
%
% %@doc unsuccess_sme composite record definition.
%
% &lt;p&gt;The macro ?UNSUCCESS_SME_DATATYPE defines the type specifier for this
% field.&lt;/p&gt;
%
% &lt;dl&gt;
%   &lt;dt&gt;DestAddrTon: &lt;/dt&gt;&lt;dd&gt;Indicates Type of Number for destination.
%     Integer, 1 octet (default is ?TON_INTERNATIONAL).
%   &lt;/dd&gt;
%   &lt;dt&gt;DestAddrNpi: &lt;/dt&gt;&lt;dd&gt;Numbering Plan Indicator for destination.
%     Integer, 1 octet  (default is ?NPI_ISDN).
%   &lt;/dd&gt;
%   &lt;dt&gt;DestinationAddr: &lt;/dt&gt;&lt;dd&gt;Destination address of this short message.
%     For mobile terminated messages, this is the directory number of the
%     recipient MS.  C-Octet String, Var. max 21 octets.
%   &lt;/dd&gt;
%   &lt;dt&gt;ErrorStatusCode: &lt;/dt&gt;&lt;dd&gt;Indicates the success or failure of the
%     submit_multi request to this SME address.  Check command_status
%     macros for a complete list of SMPP Error codes.  Integer, 4 octets.
%   &lt;/dd&gt;
% &lt;/dl&gt;
% %@end
%%
-record(unsuccess_sme,
        {dest_addr_ton     = ?TON_INTERNATIONAL,
         dest_addr_npi     = ?NPI_ISDN,
         destination_addr,
         error_status_code}).
</pre>

<p>The rest of SMPP operation functions have a <tt>ParamList</tt> 
argument also, and work much like <a href="gen_esme.html#submit_sm-2">
gen_esme:submit_sm/2</a> does.</p>

<p>Now let's take a look at the callbacks exported by 
<a href="gen_esme.html">gen_esme</a>.  That's where you implement the logic 
associated to your particular ESME.</p>

<p>Under a connection failure, the <a href="gen_esme.html">gen_esme</a> 
behavior will try to reestablish the sessions to the SMSC for ever.  If we 
wanted to change this behavior for our echo ESME, we needed to implement the 
callbacks: <a href="gen_esme.html#receiver_mc_unavailable-4">gen_esme:receiver_mc_unavailable/4</a> and/or <a href="gen_esme.html#transmitter_mc_unavailable/4">gen_esme:transmitter_mc_unavailable/4</a>.  For instance, if we wanted our 
echo ESME to notify the error somewhere and then halt, whenever the receiver 
session goes down, just need to do:
</p>

<pre>
receiver_mc_unavailable(Pid, Eid, Address, Port) -&gt;
    % Notify the error 
    ...

    stop().
</pre>

<p>Look at the callbacks exported by the <a href="gen_esme.html">gen_esme</a> 
behavior, to see how much you can customize your particular ESME 
implementation.</p>

<p>Developers should implement the callbacks their ESME is going to take care 
of. Leaving a callback undefined retains the default behavior, which should be 
OK if you don't want your ESME to handle that operation.</p>


<h4><a name="code_lock">Code lock ESME example</a></h4>

We'll look now at the code_lock FSM example presented in the 
<a href="http://www.erlang.org/doc/r9c/doc/design_principles/part_frame.html">Design Principles</a>.

<pre>
-module(code_lock).
-behaviour(gen_fsm).

-export([start_link/1, stop/0]).
-export([button/1]).
-export([init/1, closed/2, open/2, handle_event/3, terminate/3]).

start_link(Code) -&gt;
    gen_fsm:start_link({local, code_lock}, code_lock, Code, []).

stop() -&gt;
    gen_fsm:send_all_state_event(code_lock, stop).


button(Digit) -&gt;
    gen_fsm:send_event(code_lock, {button, Digit}).

init(Code) -&gt;
    {ok, closed, {[], Code}}.

closed({button, Digit}, {SoFar, Code}) -&gt;
    case [Digit|SoFar] of
        Code -&gt;
            do_open(),
            {next_state, open, {[], Code}, 3000};
        Incomplete when length(Incomplete) &lt; length(Code) -&gt;
            {next_state, closed, {Incomplete, Code}};
        _Wrong -&gt;
            {next_state, closed, {[], Code}}
    end.

open(timeout, State) -&gt;
    do_close(),
    {next_state, closed, State}.

handle_event(stop, _StateName, StateData) -&gt;
    {stop, normal, StateData}.

terminate(normal, StateName, StateData) -&gt;
    ok.
 
do_open() -&gt;
    io:format("do open~n", []).

do_close() -&gt;
    io:format("do close~n", []).
</pre>    

<p>Save this code in a module called <b>code_lock.erl</b>, compile it, 
and see how it works:</p>

<pre>
    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; c(code_lock).
    ok
    2&gt; code_lock:start_link([1,2]).
    {ok,&lt;0.34.0&gt;}
    3&gt; code_lock:button(2).
    ok
    4&gt; code_lock:button(1).
    do open
    ok
    do close
    5&gt; code_lock:stop().
    ok
    6&gt;
</pre>

<p>Imagine now we want to implement an ESME to open this door through SMS.
The user must send all the digits in sequence to unlock the door, one digit per
short message.  Not too useful I know, but this is just another weird example.
</p>

<p>We will also implement a rudimentary mechanism to let a user keep the 
control of the door until he/she enters all the digits.  In the meanwhile, 
messages from other users shall be ignored.</p>

<p>The source code for such an ESME is shown at 
<a href="examples/code_lock_esme.erl">doc/examples/code_lock_esme.erl</a>.</p>

<p>Compile it and test it just like previous examples.</p>

<pre>
    $ erlc -W -I ../../include -pz ../../ebin code_lock_esme.erl

    $ erl
    Erlang (BEAM) emulator version 5.2 [source] [hipe]

    Eshell V5.2  (abort with ^G)
    1&gt; executing user profile in HOME/.erlang
    .erlang rc finished
    1&gt; code:add_path("../../../common_lib/ebin").
    true
    2&gt; code:add_path("../../ebin").
    true
    3&gt; code_lock_esme:start().
    Starting the code lock ESME...bound as receiver/transceiver
    {ok,&lt;0.29.0&gt;}
</pre>

<p>This service is available at address <i>1949</i>.  A short message with the 
text "2" arrives (sender has the address 981654321)
</p>

<pre>
    Digit: 2
    Caller: [{dest_addr_ton,0},{dest_addr_npi,0},{destination_addr,"981654321"}]
</pre>

<p>At this point the user with address 981654321 has the control.  If 
another user, with address 981123456, tries to unlock the door...
</p>
<pre>
    Digit: 2
    Caller: [{dest_addr_ton,0},{dest_addr_npi,0},{destination_addr,"981123456"}]
    Submitted SM: "Please, wait your turn"
    Destination: [{dest_addr_ton,0},
                  {dest_addr_npi,0},
                  {destination_addr,"981123456"}]
</pre>

<p>Send the second digit (a Short Message with the text "1" from 981654321) 
gets to our code lock ESME:</p>

<pre>
    Digit: 1
    Caller: [{dest_addr_ton,0},{dest_addr_npi,0},{destination_addr,"981654321"}]
    Submitted SM: "Came in please.  The door is open"
    Destination: [{dest_addr_ton,0},
                  {dest_addr_npi,0},
                  {destination_addr,"981654321"}]
    Submitted SM: "Closing the door. Please, hurry up."
    Destination: [{dest_addr_ton,0},
                  {dest_addr_npi,0},
                  {destination_addr,"981654321"}]
    4&gt; code_lock_esme:stop().
    Stopping the code lock ESME...ok
    done
</pre>

<p>In the meanwhile, this is what the SMSC log looks like:</p>

<pre>
2004.02.07 11:33:48 539 INFO    CH10: BIND_RECEIVER:
2004.02.07 11:33:48 539 INFO    Hex dump (39) bytes:
2004.02.07 11:33:48 539 INFO    00000027:00000001:00000000:00000001:
2004.02.07 11:33:48 539 INFO    62616E61:6E610073:65637265:74000050:
2004.02.07 11:33:48 539 INFO    01013139:343900
2004.02.07 11:33:48 539 INFO
2004.02.07 11:33:48 540 INFO    SMPPReceiver: setting address range to 1949
2004.02.07 11:33:48 540 INFO    CH10: BIND_RECEIVER_RESP:
2004.02.07 11:33:48 540 INFO    Hex dump (24) bytes:
2004.02.07 11:33:48 540 INFO    00000018:80000001:00000000:00000001:
2004.02.07 11:33:48 540 INFO    534D5050:53696D00:
2004.02.07 11:33:48 540 INFO
2004.02.07 11:33:48 540 INFO    1 receivers connected and bound
2004.02.07 11:33:48 544 INFO    ConnectionHandler CH11 accepted a connection
2004.02.07 11:33:48 546 INFO    CH11: BIND_TRANSMITTER:
2004.02.07 11:33:48 546 INFO    Hex dump (39) bytes:
2004.02.07 11:33:48 546 INFO    00000027:00000002:00000000:00000001:
2004.02.07 11:33:48 547 INFO    62616E61:6E610073:65637265:74000050:
2004.02.07 11:33:48 547 INFO    01013139:343900
2004.02.07 11:33:48 547 INFO
2004.02.07 11:33:48 551 INFO    CH11: BIND_TRANSMITTER_RESP:
2004.02.07 11:33:48 551 INFO    Hex dump (24) bytes:
2004.02.07 11:33:48 551 INFO    00000018:80000002:00000000:00000001:
2004.02.07 11:33:48 551 INFO    534D5050:53696D00:
2004.02.07 11:33:48 551 INFO
2004.02.07 11:34:16 733 INFO    HC0 accepted connection
2004.02.07 11:34:16 736 INFO    HC0: DELIVER_SM
2004.02.07 11:34:16 737 INFO    DELIVER_SM:
2004.02.07 11:34:16 737 INFO    Hex dump (47) bytes:
2004.02.07 11:34:16 737 INFO    0000002F:00000005:00000000:00000008:
2004.02.07 11:34:16 737 INFO    00000039:38313635:34333231:00000031:
2004.02.07 11:34:16 737 INFO    39343900:00000000:00000000:000132
2004.02.07 11:34:16 737 INFO
2004.02.07 11:34:16 737 INFO    HTTPController HC0 waiting for connection
2004.02.07 11:34:16 740 INFO    CH10: DELIVER_SM_RESP:
2004.02.07 11:34:16 740 INFO    Hex dump (27) bytes:
2004.02.07 11:34:16 741 INFO    0000001B:80000005:00000000:00000008:
2004.02.07 11:34:16 741 INFO    00001D00:01000428:000100
2004.02.07 11:34:16 741 INFO
2004.02.07 11:34:43 900 INFO    HC0 accepted connection
2004.02.07 11:34:43 901 INFO    HC0: DELIVER_SM
2004.02.07 11:34:43 902 INFO    DELIVER_SM:
2004.02.07 11:34:43 902 INFO    Hex dump (47) bytes:
2004.02.07 11:34:43 903 INFO    0000002F:00000005:00000000:00000009:
2004.02.07 11:34:43 903 INFO    00000039:38313132:33343536:00000031:
2004.02.07 11:34:43 903 INFO    39343900:00000000:00000000:000132
2004.02.07 11:34:43 904 INFO
2004.02.07 11:34:43 904 INFO    HTTPController HC0 waiting for connection
2004.02.07 11:34:43 908 INFO    CH10: DELIVER_SM_RESP:
2004.02.07 11:34:43 908 INFO    Hex dump (27) bytes:
2004.02.07 11:34:43 908 INFO    0000001B:80000005:00000000:00000009:
2004.02.07 11:34:43 908 INFO    00001D00:01000428:000100
2004.02.07 11:34:43 908 INFO
2004.02.07 11:34:43 909 INFO    CH11: SUBMIT_SM:
2004.02.07 11:34:43 909 INFO    Hex dump (134) bytes:
2004.02.07 11:34:43 909 INFO    00000086:00000004:00000000:00000002:
2004.02.07 11:34:43 909 INFO    00010131:39343900:00003938:31313233:
2004.02.07 11:34:43 909 INFO    34353600:00000000:00000003:0016506C:
2004.02.07 11:34:43 909 INFO    65617365:2C207761:69742079:6F757220:
2004.02.07 11:34:43 909 INFO    7475726E:00050001:00000700:01010006:
2004.02.07 11:34:43 909 INFO    00010100:08000200:00042400:00001900:
2004.02.07 11:34:43 909 INFO    0100020F:00010102:0E000101:04210001:
2004.02.07 11:34:43 910 INFO    01000D00:0100000F:00010100:0E000101:
2004.02.07 11:34:43 910 INFO    00100002:0000
2004.02.07 11:34:43 910 INFO
2004.02.07 11:34:43 911 INFO    CH11:SUBMIT_SM_RESP:
2004.02.07 11:34:43 911 INFO    Hex dump (25) bytes:
2004.02.07 11:34:43 911 INFO    00000019:80000004:00000000:00000002:
2004.02.07 11:34:43 911 INFO    31353730:33353535:00
2004.02.07 11:34:43 911 INFO
</pre>

<p>One comment here, notice there is one minute of inactivity since last 
submit, while in the demonstration above, I've intentionally waited 1 minute 
before sending the last SM, see how the <a href="gen_esme.html">gen_esme</a> 
behavior transparently handles inactivity timers (look at the enquire links in 
both sessions).</p>
 
<pre>
2004.02.07 11:35:43 916 INFO    CH11: ENQUIRE_LINK:
2004.02.07 11:35:43 916 INFO    Hex dump (16) bytes:
2004.02.07 11:35:43 916 INFO    00000010:00000015:00000000:00000003:
2004.02.07 11:35:43 916 INFO
2004.02.07 11:35:43 917 INFO
2004.02.07 11:35:43 917 INFO    CH11: ENQUIRE_LINK_RESP:
2004.02.07 11:35:43 917 INFO    Hex dump (16) bytes:
2004.02.07 11:35:43 917 INFO    00000010:80000015:00000000:00000003:
2004.02.07 11:35:43 917 INFO
2004.02.07 11:35:43 917 INFO
2004.02.07 11:35:43 917 INFO    CH10: ENQUIRE_LINK:
2004.02.07 11:35:43 917 INFO    Hex dump (16) bytes:
2004.02.07 11:35:43 917 INFO    00000010:00000015:00000000:00000002:
2004.02.07 11:35:43 917 INFO
2004.02.07 11:35:43 917 INFO
2004.02.07 11:35:43 918 INFO    CH10: ENQUIRE_LINK_RESP:
2004.02.07 11:35:43 918 INFO    Hex dump (16) bytes:
2004.02.07 11:35:43 918 INFO    00000010:80000015:00000000:00000002:
2004.02.07 11:35:43 918 INFO
2004.02.07 11:35:43 918 INFO
2004.02.07 11:35:46 591 INFO    HC0 accepted connection
2004.02.07 11:35:46 592 INFO    HC0: DELIVER_SM
2004.02.07 11:35:46 595 INFO    DELIVER_SM:
2004.02.07 11:35:46 595 INFO    Hex dump (47) bytes:
2004.02.07 11:35:46 595 INFO    0000002F:00000005:00000000:0000000A:
2004.02.07 11:35:46 595 INFO    00000039:38313635:34333231:00000031:
2004.02.07 11:35:46 595 INFO    39343900:00000000:00000000:000131
2004.02.07 11:35:46 595 INFO
2004.02.07 11:35:46 595 INFO    HTTPController HC0 waiting for connection
2004.02.07 11:35:46 599 INFO    CH10: DELIVER_SM_RESP:
2004.02.07 11:35:46 599 INFO    Hex dump (27) bytes:
2004.02.07 11:35:46 599 INFO    0000001B:80000005:00000000:0000000A:
2004.02.07 11:35:46 599 INFO    00001D00:01000428:000100
2004.02.07 11:35:46 599 INFO
2004.02.07 11:35:46 600 INFO    CH11: SUBMIT_SM:
2004.02.07 11:35:46 600 INFO    Hex dump (145) bytes:
2004.02.07 11:35:46 600 INFO    00000091:00000004:00000000:00000004:
2004.02.07 11:35:46 600 INFO    00010131:39343900:00003938:31363534:
2004.02.07 11:35:46 601 INFO    33323100:00000000:00000003:00214361:
2004.02.07 11:35:46 601 INFO    6D652069:6E20706C:65617365:2E202054:
2004.02.07 11:35:46 601 INFO    68652064:6F6F7220:6973206F:70656E00:
2004.02.07 11:35:46 604 INFO    05000100:00070001:01000600:01010008:
2004.02.07 11:35:46 604 INFO    00020000:04240000:00190001:00020F00:
2004.02.07 11:35:46 604 INFO    0101020E:00010104:21000101:000D0001:
2004.02.07 11:35:46 604 INFO    00000F00:0101000E:00010100:10000200:
2004.02.07 11:35:46 604 INFO    00
2004.02.07 11:35:46 604 INFO
2004.02.07 11:35:46 605 INFO    CH11:SUBMIT_SM_RESP:
2004.02.07 11:35:46 605 INFO    Hex dump (25) bytes:
2004.02.07 11:35:46 605 INFO    00000019:80000004:00000000:00000004:
2004.02.07 11:35:46 605 INFO    33373838:30383434:00
2004.02.07 11:35:46 605 INFO
2004.02.07 11:35:49 616 INFO    CH11: SUBMIT_SM:
2004.02.07 11:35:49 617 INFO    Hex dump (147) bytes:
2004.02.07 11:35:49 617 INFO    00000093:00000004:00000000:00000005:
2004.02.07 11:35:49 617 INFO    00010131:39343900:00003938:31363534:
2004.02.07 11:35:49 617 INFO    33323100:00000000:00000003:0023436C:
2004.02.07 11:35:49 617 INFO    6F73696E:67207468:6520646F:6F722E20:
2004.02.07 11:35:49 617 INFO    506C6561:73652C20:68757272:79207570:
2004.02.07 11:35:49 617 INFO    2E000500:01000007:00010100:06000101:
2004.02.07 11:35:49 617 INFO    00080002:00000424:00000019:00010002:
2004.02.07 11:35:49 617 INFO    0F000101:020E0001:01042100:0101000D:
2004.02.07 11:35:49 617 INFO    00010000:0F000101:000E0001:01001000:
2004.02.07 11:35:49 617 INFO    020000
2004.02.07 11:35:49 617 INFO
2004.02.07 11:35:49 618 INFO    CH11:SUBMIT_SM_RESP:
2004.02.07 11:35:49 618 INFO    Hex dump (25) bytes:
2004.02.07 11:35:49 618 INFO    00000019:80000004:00000000:00000005:
2004.02.07 11:35:49 618 INFO    36393535:30323330:00
2004.02.07 11:35:49 618 INFO
2004.02.07 11:36:05 991 INFO    CH10: UNBIND
2004.02.07 11:36:05 991 INFO    Hex dump (16) bytes:
2004.02.07 11:36:05 992 INFO    00000010:00000006:00000000:00000003:
2004.02.07 11:36:05 992 INFO
2004.02.07 11:36:05 992 INFO
2004.02.07 11:36:05 992 INFO    0 receivers connected and bound
2004.02.07 11:36:05 992 INFO    CH10: UNBIND_RESP
2004.02.07 11:36:05 992 INFO    Hex dump (16) bytes:
2004.02.07 11:36:05 992 INFO    00000010:80000006:00000000:00000003:
2004.02.07 11:36:05 992 INFO
2004.02.07 11:36:05 992 INFO
2004.02.07 11:36:05 992 INFO    CH10 closing connection
2004.02.07 11:36:05 992 INFO    ConnectionHandler CH10 waiting for connection
2004.02.07 11:36:05 995 INFO    CH11: UNBIND
2004.02.07 11:36:05 997 INFO    Hex dump (16) bytes:
2004.02.07 11:36:05 997 INFO    00000010:00000006:00000000:00000006:
2004.02.07 11:36:05 997 INFO
2004.02.07 11:36:05 997 INFO
2004.02.07 11:36:05 998 INFO    CH11: UNBIND_RESP
2004.02.07 11:36:05 998 INFO    Hex dump (16) bytes:
2004.02.07 11:36:05 998 INFO    00000010:80000006:00000000:00000006:
2004.02.07 11:36:05 998 INFO
2004.02.07 11:36:05 998 INFO
2004.02.07 11:36:05 998 INFO    CH11 closing connection
2004.02.07 11:36:05 998 INFO    ConnectionHandler CH11 waiting for connection
</pre>


<h3><a name="howto_mc">How to implement a MC</a></h3>

Since current version of the library doesn't provide a MC behavior yet, MC
developing requires a greater effort at the moment.

<p>Proposed approach is to implement a generic MC session behavior, taking
the <a href="gen_esme_session.html">ESME session behavior</a> as a reference,
and then implement a generic MC behavior on top of it, just like 
<a href="gen_esme.html">gen_esme</a> relies on the 
<a href="gen_esme_session.html">gen_esme_session</a> behavior.</p>

<p>You could also contribute with these behaviors to the project, I'll be glad 
to include them on the next release.</p>


<h3><a name="tune">Fine tune OSERL's SMPP implementation</a></h3>

In order to fit OSERL to your particular needs, you may want to fine tune
some parameters and/or PDU definitions of the SMPP protocol.

<p>Redefining SMPP PDUs and parameters in OSERL is simple, since OSERL was
designed with that principle in mind.</p>

<p>There are three header files you should consider, if you want to customize
the SMPP protocol definitions:</p>

<dl>
  <dt><a href="#smpp_pdu">smpp_pdu.hrl</a></dt>
  <dd>PDUs type descriptor.</dd>
  <dt><a href="#smpp_param">smpp_param.hrl</a></dt>
  <dd>Standard and TLV parameters descriptor.</dd>
  <dt><a href="#smpp_base">smpp_base.hrl</a></dt>
  <dd>Parameters base type.</dd>
</dl>

<b>Important Note: </b><i>Don't forget to recompile the module
<a href="operation.html">operation.erl</a> for the changes on any of these 
files to take effect.</i>


<h4><a name="smpp_pdu">smpp_pdu.hrl</a></h4>

This header defines the SMPP PDU Type Declarations.

<p>Macros declaring SMPP PDU definitions and their default values.  Refer 
to <a href="operation.html">operation.erl</a> to find out how these macros 
are used.</p>

<p>Every PDU declaration consists of two lists.</p>

<dl>
  <dt><i>Standard body parameters declaration:</i></dt><dd>A list with the
    declaration of every standard parameter of the PDU body.  Header 
    parameters are *not* included on the PDU declaration.  The standard
    parameters are packed/unpacked in the order specified on this list, thus
    the order must be the one declared on [SMPP 5.0].
  </dd>
  <dt><i>TLV parameters declaration:</i></dt><dd>A list with the declaration
    of every TLV parameter of the PDU.  

    <p>Programmers may want to comment out, uncomment or even add any 
    desired TLV in order to fit the needs of a particular implementation.
    Notice that having declared unused TLVs doesn't do any harm, comment
    them out or remove'em from the TLV list on the PDU declaration only for
    efficiency sake.</p>
  </dd>
</dl>

<p>Given the following declaration:</p>

<pre>
-define(BIND_TRANSMITTER_RESP,
        ?PDU([?SYSTEM_ID],
             [?CONGESTION_STATE,
              ?SC_INTERFACE_VERSION])).
</pre>

<p>A dictionary representing this PDU must have the elements:</p>

<pre>
[{command_id, ?COMMAND_ID_BIND_TRANSMITTER_RESP},
 {command_status, CommandStatus},
 {sequence_number, SequenceNumber},
 {system_id, SystemId}]
</pre>

<p>The pair <tt>{system_id, SystemId}</tt> might be ignored if 
<tt>command_status</tt> is not 0, the following pairs are also optional:</p>

<pre>
[{congestion_state, CongestionState}, 
 {sc_interface_version, ScInterfaceVersion}]
</pre>

<p>Notice that a <tt>command_length</tt> element is not included on the 
dictionary.</p>


<h4><a name="smpp_param">smpp_param.hrl</a></h4>

SMPP Standard and TLV Parameters descriptor.  These descriptors are defined by 
means of the base types declared on <a href="#smpp_base">smpp_base</a>,
and using the syntax defined in <i>param_syntax.hrl</i>.

<p>A parameter descriptor defines the parameter name, base type, default value
and error code associated to it.</p>

<p>Feel free to adjust parameter descriptors to your particular needs.  You may
want to change the default value or the mandatory status of some TLVs.</p>

<p><b>Important Note:</b> <i>Don't forget to recompile the module
<a href="operation.html">operation.erl</a> for the changes on this file to 
take effect.</i></p>


<h4><a name="smpp_base">smpp_base.hrl</a></h4>

Base definitions for the SMPP protocol specification.  These definitions use 
the syntax defined in <i>base_syntax.hrl</i>.

<p>In this header file, parameter base datatypes, domains and reserved values
are declared.</p>


<h2><a name="storage">PDU data storage</a></h2>

PDU data is internally stored as a dictionary.  Dictionaries are defined on 
erlang's <a href="http://www.erlang.se/doc/doc-5.0.1/lib/stdlib-1.9.1/doc/">stdlib</a>.  Functions <a href="operation.html#get_param-2#">operation:get_param/2</a> and <a href="operation.html#set_param-3#">operation:set_param/3</a> may be used to get/set parameters values by name.

<p>The names of the parameters (keys of the PDU dictionary) are those on the 
SMPP protocol specification.</p>

<p>A PDU is completely defined by the content (the dictionary with the 
parameter values) and a type descriptor (terms described in the following
section).  Type descriptors declare the PDU structure, and determines the
way it must be encoded/decoded.</p>

<p>To successfully encode/decode PDU contents into binary terms, every
individual parameter value must match the type declared on the PDU descriptor. 
Users of this library won't need to care about type descriptors though.  The
<a href="http://www.des.udc.es/~mpquique/oserl/operation.html">operation</a>
module hides the details to higher layers and transparently handles the
type descriptors.</p>


<h2><a name="translation">Translating the SMPP specification</a></h2>

<p>The erlang terms used to represent the SMPP specification are intended to
adopt the conventions used on [SMPP 5.0] as much as posible.</p>

<p>The best way to understand the syntax used in OSERL to represent PDU type
descriptors, and how everything works, is by a complete example.</p>

<p>On page 74, section 4.2.3.2 of the SMPP specification [SMPP 5.0], the
<i>submit_multi_resp</i> operation PDU is defined as follows:</p>

<table width="100%" border="1" cellpadding="2">
<caption>submit_multi_resp Syntax</caption>
  <tr style="color: white; background-color : black"> 
    <th width="50%" valign="middle" align="center">Field Name</th>
    <th width="25%" valign="middle" align="center">Size Octets</th>
    <th width="25%" valign="middle" align="center">Type</th>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">command_length</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">command_id</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">command_status</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr style="color: white; background-color : grey">
    <td width="50%" valign="middle" align="center">sequence_number</td>
    <td width="25%" valign="middle" align="center">4</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">message_id</td>
    <td width="25%" valign="middle" align="center">Var. max 65</td>
    <td width="25%" valign="middle" align="center">C-Octet String</td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">no_unsuccess</td>
    <td width="25%" valign="middle" align="center">1</td>
    <td width="25%" valign="middle" align="center">Integer</td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">unsuccess_sme</td>
    <td width="25%" valign="middle" align="center">Var. max 27</td>
    <td width="25%" valign="middle" align="center">Composite</td>
  </tr>
  <tr>
    <td width="50%" valign="middle" align="center">
      <table width="100%" border="0" cellpadding="2">
        <tr>
          <td width="100%" align="center">dest_addr_ton</td>
        </tr>
        <tr>
          <td width="100%" align="center">dest_addr_npi</td>
        </tr>
        <tr>
          <td width="100%" align="center">destination_addr</td>
        </tr>
        <tr>
          <td width="100%" align="center">error_status_code</td>
        </tr>
      </table>
    </td>
    <td width="25%" valign="middle" align="center">
      <table width="100%" border="0" cellpadding="2">
        <tr>
          <td width="100%" align="center">1</td>
        </tr>
        <tr>
          <td width="100%" align="center">1</td>
        </tr>
        <tr>
          <td width="100%" align="center">Var. max 21</td>
        </tr>
        <tr>
          <td width="100%" align="center">4</td>
        </tr>
      </table>
    </td>
    <td width="25%" valign="middle" align="center">
      <table width="100%" border="0" cellpadding="2">
        <tr>
          <td width="100%" align="center">Integer</td>
        </tr>
        <tr>
          <td width="100%" align="center">Integer</td>
        </tr>
        <tr>
          <td width="100%" align="center">C-Octet String</td>
        </tr>
        <tr>
          <td width="100%" align="center">Integer</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr> 
    <td width="50%" valign="middle" align="center">
      Message Submission Response TLVs
    </td>
    <td width="25%" valign="middle" align="center">Var</td>
    <td width="25%" valign="middle" align="center">TLV</td>
  </tr>
</table>

<p><tt>unsuccess_sme</tt> is a composite field containing an SME address 
(<tt>dest_addr_ton</tt>, <tt>dest_addr_npi</tt> and <tt>destination_addr</tt>) 
and an error code (<tt>error_status_code</tt>).  Additionally the field can be 
encoded multiple times according to the value specified in the 
<tt>no_unsuccess</tt> field.</p>

<table width="100%" border="1" cellpadding="2">
<caption>Message Submission Response TLVs</caption>
  <tr style="color: white; background-color : black"> 
    <th width="40%" valign="middle" align="center">TLV Name</th>
    <th width="20%" valign="middle" align="center">Tag</th>
    <th width="20%" valign="middle" align="center">Size Octets</th>
    <th width="20%" valign="middle" align="center">Type</th>
  </tr>
  <tr>
    <td width="40%" valign="middle" align="center">
      additional_status_info_text
    </td>
    <td width="20%" valign="middle" align="center">0x001D</td>
    <td width="20%" valign="middle" align="center">1-256</td>
    <td width="20%" valign="middle" align="center">C-Octet String</td>
  </tr>
  <tr>
    <td width="30%" valign="middle" align="center">delivery_failure_reason</td>
    <td width="20%" valign="middle" align="center">0x0425</td>
    <td width="20%" valign="middle" align="center">1</td>
    <td width="20%" valign="middle" align="center">Integer</td>
  </tr>
  <tr>
    <td width="30%" valign="middle" align="center">dpf_result</td>
    <td width="20%" valign="middle" align="center">0x0420</td>
    <td width="20%" valign="middle" align="center">1</td>
    <td width="20%" valign="middle" align="center">Integer</td>
  </tr>
  <tr>
    <td width="30%" valign="middle" align="center">network_error_code</td>
    <td width="20%" valign="middle" align="center">0x0423</td>
    <td width="20%" valign="middle" align="center">3</td>
    <td width="20%" valign="middle" align="center">Octet String</td>
  </tr>
</table>

<p>This PDU type is internaly represented by the following descriptor:</p>

<pre>
-define(SUBMIT_MULTI_RESP,
        ?PDU([?MESSAGE_ID, 
              ?UNSUCCESS_SME],
             [?ADDITIONAL_STATUS_INFO_TEXT,
              ?CONGESTION_STATE,
              ?DELIVERY_FAILURE_REASON,
              ?DPF_RESULT,
              ?NETWORK_ERROR_CODE])).
</pre>

<p>This macro definition can be found in the header file 
<b>smpp_pdu.hrl</b></p>

<p>Since the format of the header is common to every PDU type, it doesn't need
to be declared.  Although is a bit surprising to find out that not even the 
<tt>command_id</tt> is included in this descriptor.  Let us see the 
reason.</p>

<p>The procedure for decoding a PDU could be roughly described by these 
three steps:</p>

<ol>
  <li>Decode the header of the PDU and get the <tt>command_id</tt>.</li>
  <li>Find the PDU descriptor associatted to that <tt>command_id</tt>.</li>
  <li>Use the PDU descriptor to decode the body of the PDU.</li>
</ol>

<p>Thus a PDU decoding function needs, during step 2, access to the entire 
list of SMPP PDU descriptors.  In a first approach, the <tt>command_ids</tt> 
were included inside each PDU descriptor, but then the entire list of 
descriptors ought to be given to the decoding function as a parameter.  This 
list was too heavy and the resulting decoding process slow (too slow...
useless).</p>

<p>To speed up the process the <tt>command_id</tt> was separated from the
descriptor and a new function (<a name="operation.html#pdu_type-1">
operation:pdu_type/1</a>) defined.  Now the decoding process iterates 
through the list of <tt>command_ids</tt> and only when a math occurs, the
corresponding PDU descriptor is taken with <tt>pdu_type(command_id)</tt>.</p>

<p>The first approach was more elegant but unfortunately cannot be considered 
until I find a better way to exploit it.</p>

<p>Recalling the internal representation of the PDU, every individual field is 
defined in <b>smpp_param.hrl</b> as:</p>

<pre>
-define(MESSAGE_ID, 
        ?STANDARD(message_id, 
                  ?MESSAGE_ID_DOMAIN, 
                  ?ESME_RINVMSGID)).

-define(UNSUCCESS_SME, 
        ?STANDARD(unsuccess_sme, 
                  ?UNSUCCESS_SME_DOMAIN, 
                  ?ESME_RINVDSTADR)).

-define(ADDITIONAL_STATUS_INFO_TEXT, 
        ?OPTIONAL_TLV(additional_status_info_text,
                      16#001D, 
                      ?ADDITIONAL_STATUS_INFO_TEXT_DOMAIN, 
                      ?ADDITIONAL_STATUS_INFO_TEXT_RESERVED, 
                      undefined, 
                      undefined)).

-define(CONGESTION_STATE, 
        ?OPTIONAL_TLV(congestion_state,
                      16#0428, 
                      ?CONGESTION_STATE_DOMAIN, 
                      ?CONGESTION_STATE_RESERVED, 
                      undefined, 
                      undefined)).

-define(DELIVERY_FAILURE_REASON, 
        ?OPTIONAL_TLV(delivery_failure_reason,
                      16#0425, 
                      ?DELIVERY_FAILURE_REASON_DOMAIN, 
                      ?DELIVERY_FAILURE_REASON_RESERVED, 
                      undefined, 
                      undefined)).

-define(DPF_RESULT, 
        ?OPTIONAL_TLV(dpf_result,
                      16#0420, 
                      ?DPF_RESULT_DOMAIN, 
                      ?DPF_RESULT_RESERVED, 
                      ?DPF_RESULT_NOT_SET, 
                      undefined)).

-define(NETWORK_ERROR_CODE, 
        ?OPTIONAL_TLV(network_error_code,
                      16#0423, 
                      ?NETWORK_ERROR_CODE_DOMAIN, 
                      ?NETWORK_ERROR_CODE_RESERVED, 
                      undefined, 
                      undefined)).
</pre>

<p>Domains and reserved values are defined in <b>smpp_base.hrl</b>.</p>

<pre>
%%%
% message_id
%%
-define(MESSAGE_ID_DOMAIN, ?VAR_C_OCTET_STRING(65)).

%%%
% unsuccess_sme
%%
-define(UNSUCCESS_SME_ITEM_DOMAIN,
        ?COMPOSITE(unsuccess_sme,
                   {?TON_DOMAIN,
                    ?NPI_DOMAIN,
                    ?ADDR_21_DOMAIN,
                    ?SMPP_ERROR_DOMAIN})).

-define(UNSUCCESS_SME_DOMAIN, ?LIST(?UNSUCCESS_SME_ITEM_DOMAIN)).

%%%
% additional_status_info_text
%%
-define(ADDITIONAL_STATUS_INFO_TEXT_DOMAIN,   ?VAR_C_OCTET_STRING(256)).
-define(ADDITIONAL_STATUS_INFO_TEXT_RESERVED, ?EMPTY).

%%%
% congestion_state
%%
-define(CONGESTION_STATE_DOMAIN,   ?BOUND_INTEGER(1, 99)).
-define(CONGESTION_STATE_RESERVED, ?RANGE_INTEGER(1, 100, 255)).

%%%
% delivery_failure_reason
%%
-define(DELIVERY_FAILURE_REASON_DOMAIN,   ?BOUND_INTEGER(1, 3)).
-define(DELIVERY_FAILURE_REASON_RESERVED, ?RANGE_INTEGER(1, 4, 255)).

%%%
% dpf_result
%%
-define(DPF_RESULT_DOMAIN,   ?BOUND_INTEGER(1, 1)).
-define(DPF_RESULT_RESERVED, ?RANGE_INTEGER(1, 2, 255)).

%%%
% network_error_code
%%
-define(NETWORK_ERROR_CODE_TYPE_DOMAIN,   ?RANGE_INTEGER(1, 1, 8)).
-define(NETWORK_ERROR_CODE_TYPE_RESERVED,   
        ?UNION([?CONSTANT(0), ?RANGE_INTEGER(1, 9, 255)])).

-define(NETWORK_ERROR_CODE_ERROR_DOMAIN,   ?INTEGER(2)).
-define(NETWORK_ERROR_CODE_ERROR_RESERVED, ?INTEGER(2)).

-define(NETWORK_ERROR_CODE_DOMAIN, 
        ?COMPOSITE(network_error_code,
                   {?NETWORK_ERROR_CODE_TYPE_DOMAIN,
                    ?NETWORK_ERROR_CODE_ERROR_DOMAIN})).
-define(NETWORK_ERROR_CODE_RESERVED, 
        ?COMPOSITE(network_error_code,
                   {?NETWORK_ERROR_CODE_TYPE_RESERVED,
                    ?NETWORK_ERROR_CODE_ERROR_RESERVED})).
</pre>


<p>Notice that <tt>UNSUCCESS_SME_DOMAIN</tt> embraces the definition of both 
fields; <tt>unsuccess_sme</tt> and <tt>no_unsuccess</tt>, since a list is 
<a href="base_syntax.html#encode-list">encoded in a Length ++ List</a> fashion,
<tt>no_unsuccess</tt> doesn't need to be explicitly declared.</p>

<p>Additionally, two records must be defined in order to successfully decode 
named composites:</p>

<pre>
-record(unsuccess_sme, 
        {dest_addr_ton     = ?TON_INTERNATIONAL,
         dest_addr_npi     = ?NPI_ISDN,
         destination_addr,
         error_status_code}).

-record(network_error_code, 
        {type  = ?NETWORK_ERROR_CODE_TYPE_GSM,
         error}).
</pre>

<p>Record identifiers must match the names provided in the composite 
declaration for the decoding function to work propertly.  These names are 
ignored by the encode function though.</p>

<p>Please read documentation, comments and examples on the source code for 
further details.</p>


<h2><a name="base">Base Syntax</a></h2>

<p>The base syntax is an internal representation for the base types defined on
the SMPP specification.</p>

<p>Some base types are explicitly defined on the protocol specification, but
many of them didn't became necessary until the PDUs were examined in greater 
detail.  Data-types like <tt>lists</tt> or <tt>composites</tt> are needed to
support PDU fields that may appear multiple times, or fields that happen to
be always grouped together inside a given PDU definition.</p>

<p>The following base types are defined as records on the base syntax:</p>

<ol>
  <li><a href="#constant">constant</a></li>
  <li><a href="#integer">integer</a></li>
  <li><a href="#c_octet_string">c_octet_string</a></li>
  <li><a href="#octet_string">octet_string</a></li>
  <li><a href="#list">list</a></li>
  <li><a href="#composite">composite</a></li>
  <li><a href="#union">union</a></li>
</ol>


<h3><a name="constant">constant</a></h3>

<p><tt>-record(constant, {value})</tt>
  <ul>
    <li><tt>Value = bin()</tt></li>
  </ul>
</p>

<p>Constant declaration.  Constants are defined in binary format and
their value is packed as is.</p>

<dl>
  <dt>Value: </dt><dd>Binary constant value.</dd>
</dl>


<h3><a name="integer">integer</a></h3>

<p><tt>-record(integer, {size, min, max})</tt>
  <ul>
    <li><tt>Size = int()</tt></li>
    <li><tt>Min  = int()</tt></li>
    <li><tt>Max  = int()</tt></li>
  </ul>
</p>

<p>Integer data-type declaration.</p>

<dl>
  <dt>Size: </dt><dd>Size in octets.</dd>
  <dt>Min: </dt><dd>Lower limit (included).</dd>
  <dt>Max: </dt><dd>Upper limit (included).</dd>
</dl>

<p>Refer to section 3.1 on [SMPP 5.0]</p>


<h3><a name="c_octet_string">c_octet_string</a></h3>

<p><tt>-record(c_octet_string, {fixed, size, format})</tt>
  <ul>
    <li><tt>Fixed  = bool()</tt></li>
    <li><tt>Size   = int()</tt></li>
    <li><tt>Format = free | hex | dec</tt></li>
  </ul>
</p>

<p>C-Octet String data-type declaration.  A C-Octet String must always 
be NULL terminated, thus the minimun length allowed is 1 octet.</p>

<dl>
  <dt>Fixed: </dt><dd>String size may be of variable or fixed length.  When
    fixed the length must be exactly Size octets long, if not fixed it may
    be from 1 up to Size octets long.
  </dd>
  <dt>Size: </dt><dd>Size in octets.</dd>
  <dt>Format: </dt><dd>
    <ul>
      <li>free: a free fomat string.</li>
      <li>hex: the string represents an hexadecimal digit sequence.</li>
      <li>dec: the string represents a decimal digit sequence.</li>
    </ul>
  </dd>
</dl>

<p>Refer to section 3.1 on [SMPP 5.0]</p>


<h3><a name="octet_string">octet_string</a></h3>

<p><tt>-record(octet_string, {fixed, size, format})</tt>
  <ul>
    <li><tt>Fixed  = bool()</tt></li>
    <li><tt>Size   = int()</tt></li>
    <li><tt>Format = free | hex | dec</tt></li>
  </ul>
</p>

<p>Octet String data-type declaration.  An Octet String is not necessary
to be NULL terminated, thus the minimun length allowed is 0 octets.</p>

<dl>
  <dt>Fixed: </dt><dd>String size may be of variable or fixed length.  When
    fixed the length must be exactly Size octets long, if not fixed it may
    be from 0 up to Size octets long.
  </dd>
  <dt>Size: </dt><dd>Size in octets.</dd>
  <dt>Format: </dt><dd>
    <ul>
      <li>free: a free fomat string.</li>
      <li>hex: the string represents an hexadecimal digit sequence.</li>
      <li>dec: the string represents a decimal digit sequence.</li>
    </ul>
  </dd>
</dl>

<p>Refer to section 3.1 on [SMPP 5.0]</p>


<h3><a name="list">list</a></h3>

<p><tt>-record(list, {type, size})</tt>
  <ul>
    <li><tt>Type     = {constant, Value}</tt>
           <br/><tt> | {integer, Size, Min, Max}</tt>
           <br/><tt> | {c_octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {list, Type, Size}</tt>
           <br/><tt> | {composite, Name, Tuple}</tt>
           <br/><tt> | {union, Types}</tt></li>   
    <li><tt>Value    = bin()</tt></li>
    <li><tt>Size     = int()</tt></li>
    <li><tt>Min      = int()</tt></li>
    <li><tt>Max      = int()</tt></li>
    <li><tt>Format   = free | hex | dec</tt></li>
    <li><tt>Fixed    = bool()</tt></li>
    <li><tt>Name     = atom()</tt></li>
    <li><tt>Tuple    = term()</tt></li>
    <li><tt>Types    = [Type]</tt></li>
  </ul>
</p>

<p>List data-type declaration.  Represents a list with elements of
the same Type.</p>

<p>Notice that nested data-type definitions are allowed.  Type could be:</p>

<ul>
  <li>a constant, even it doesn't make much sense.</li>
  <li>basic data-type; integer, c_octet_string or octet_string.  A list
    of basic values.
  </li>
  <li>complex data-type such as tlvs lists, composites or union
     declarations.
  </li>
</ul>

<dl>
  <dt>Type: </dt><dd>Defines the type of the elements on the list.  Any
    kind of data-type declaration is valid.
  </dd>
  <dt>Size: </dt><dd>Maximum number of elements.</dd>
</dl>


<h3><a name="composite">composite</a></h3>

<p><tt>-record(composite, {name, tuple})</tt>
  <ul>
    <li><tt>Name  = atom()</tt></li>
    <li><tt>Tuple = term()</tt></li>
  </ul>
</p>

<p>Composite data-type declaration.  If <tt>Name</tt> is undefined the
composite is said to be anonymous and thus represented by a tuple.  Named 
composites are represented by records of type <tt>Name</tt>.  It is 
responsibility of the programmer to provide the appropriate record 
definitions.</p>

<p><tt>Name</tt> is ignored when encoding the value into a binary stream.  It
is only considered to translate the binary representation of a composite
into erlang records.  It also helps to document the declaration of nested
data structures.  It'll be a good practice to give the composite (and the
associated record) the same <tt>Name</tt> that the SMPP Protocol
Specification uses [SMPP 5.0].</p>  

<p>Whether named or not, <tt>Tuple</tt> is a tuple (never a record) defining 
the type structure of the composite.  For example, in a composite with two 
fields; an integer and an octet_string, <tt>Tuple</tt> would be something 
like:</p>

<p><tt>{?INTEGER_4, VAR_OCTET_STRING(21)}</tt></p>

<p>Nested data-type definitions are allowed.  An element on the composite may
be of the type:</p>

<ul>
  <li>constants.</li>
  <li>basic data-types; integer, c_octet_string or octet_string.</li>
  <li>complex data-types such as lists, composites or union declarations.</li>
</ul>

<dl>
  <dt>Name: </dt><dd>Identifier of the composite.  Must be left undefined if
    the composite is anonymous.
  </dd>
  <dt>Tuple: </dt><dd>Defines the structure of the composite.  Any kind of 
    data-type declaration is a valid term of this tuple.
  </dd>
</dl>


<h3><a name="union">union</a></h3>

<p><tt>-record(union, {types})</tt>
  <ul>
    <li><tt>Types    = [Type]</tt></li>
    <li><tt>Type     = {constant, Value}</tt>
           <br/><tt> | {integer, Size, Min, Max}</tt>
           <br/><tt> | {c_octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {octet_string, Fixed, Size, Format}</tt>
           <br/><tt> | {list, Type, Size}</tt>
           <br/><tt> | {composite, Name, Tuple}</tt>
           <br/><tt> | {union, Types}</tt></li>
    <li><tt>Value    = bin()</tt></li>
    <li><tt>Size     = int()</tt></li>
    <li><tt>Min      = int()</tt></li>
    <li><tt>Max      = int()</tt></li>
    <li><tt>Fixed    = bool()</tt></li>
    <li><tt>Format   = free | hex | dec</tt></li>
    <li><tt>Name     = atom()</tt></li>
    <li><tt>Tuple    = term()</tt></li>
  </ul>
</p>

<p>Union data-type declaration.  Defines a new type which is the union of
<tt>types</tt>.  For example the destination address in a <i>submit_multi</i> 
command represents either a distribution list or an SME address (these 
addresses have different data-types).</p>

<p><tt>{union, [SmeAddress, DlAddress]}</tt></p>

<p>where <tt>SmeAddress</tt> and <tt>DlAddress</tt> are composite 
data-type definitions.  Notice that nested data-type declarations are
allowed.  In SMPP the union declaration is mainly used in examples like
the one above mentioned, where the union types are composites.</p>

<dl>
  <dt>Types: </dt><dd>A list with the types of the union.</dd>
</dl>


<h2><a name="basemacros">Base Syntax Macros</a></h2>

<p>Macros based on record data-types definitions</p>

<pre>
-define(CONSTANT(Value), 
        #constant{value = Value}).
-define(INTEGER(Size), 
        #integer{size = Size, min = 0, max = math:pow(256, Size) - 1}).
-define(C_OCTET_STRING(Fixed, Size),
        #c_octet_string{fixed = Fixed, size = Size, format = free}).
-define(OCTET_STRING(Fixed, Size),
        #octet_string{fixed = Fixed, size = Size, format = free}).
-define(LIST(Type), 
        #list{type = Type, size = 255}).
-define(COMPOSITE(Name, Tuple), 
        #composite{name = Name, tuple = Tuple}).
-define(UNION(Types), 
        #union{types = Types}).</pre>


<p>Simplified macros, some options are implicitly assigned.  Most of the SMPP 
PDU fields definitions are more readable using these macros.</p>

<pre>
-define(BOUND_INTEGER(Size, Max), 
        #integer{size = Size, min = 0, max = Max}).
-define(RANGE_INTEGER(Size, Min, Max), 
        #integer{size = Size, min = Min, max = Max}).

-define(HEX_C_OCTET_STRING(Fixed, Size),
        #c_octet_string{fixed = Fixed, size = Size, format = hex}).
-define(HEX_OCTET_STRING(Fixed, Size),
        #octet_string{fixed = Fixed, size = Size, format = hex}).

-define(DEC_C_OCTET_STRING(Fixed, Size),
        #c_octet_string{fixed = Fixed, size = Size, format = dec}).
-define(DEC_OCTET_STRING(Fixed, Size),
        #octet_string{fixed = Fixed, size = Size, format = dec}).

-define(ANONYMOUS_COMPOSITE(Tuple), #composite{tuple = Tuple}).

-define(VAR_C_OCTET_STRING(Size),   ?C_OCTET_STRING(false, Size)).
-define(VAR_OCTET_STRING(Size),     ?OCTET_STRING(false, Size)).
-define(FIXED_C_OCTET_STRING(Size), ?C_OCTET_STRING(true, Size)).
-define(FIXED_OCTET_STRING(Size),   ?OCTET_STRING(true, Size)).

-define(VAR_HEX_C_OCTET_STRING(Size),   ?HEX_C_OCTET_STRING(false, Size)).
-define(VAR_HEX_OCTET_STRING(Size),     ?HEX_OCTET_STRING(false, Size)).
-define(FIXED_HEX_C_OCTET_STRING(Size), ?HEX_C_OCTET_STRING(true, Size)).
-define(FIXED_HEX_OCTET_STRING(Size),   ?HEX_OCTET_STRING(true, Size)).

-define(VAR_DEC_C_OCTET_STRING(Size),   ?DEC_C_OCTET_STRING(false, Size)).
-define(VAR_DEC_OCTET_STRING(Size),     ?DEC_OCTET_STRING(false, Size)).
-define(FIXED_DEC_C_OCTET_STRING(Size), ?DEC_C_OCTET_STRING(true, Size)).
-define(FIXED_DEC_OCTET_STRING(Size),   ?DEC_OCTET_STRING(true, Size)).

-define(SIZED_LIST(Type, Size), 
        #list{type = Type, size = Size}).
</pre>

<p>Sets
</p>

<pre>
-define(EMPTY,     ?UNION([])).
-define(SET(List), ?UNION(lists:map(fun(C) -&gt; ?CONSTANT(C) end, List))).
</pre>


<h2><a name="param">Param Syntax</a></h2>

<p>Standard and TLV parameter syntax definition.  This layer complements
the base syntax defined in the file <b>base_syntax.hrl</b>, giving
to the parameter definitions the possibility to specify an associated error
code, a default value and a tag (on TLVs only).  A complete list of the SMPP
parameters specification is defined in <b>smpp_param.hrl</b>, based
on macros defined below and the syntax declarations included in
<b>smpp_base.hrl</b>.</p>

<p>Even this syntax is considered implementation-specific, the definitions 
herein included try to reflect the conventions used on [SMPP 5.0].</p>

<p>The following types are defined as records on the param syntax:</p>

<ol>
  <li><a href="#standard">standard</a></li>
  <li><a href="#tlv">tlv</a></li>
</ol>


<h3><a name="standard">standard</a></h3>

<p><tt>-record(standard, {name, domain, error})</tt>
  <ul>
    <li><tt>Name   = atom()</tt></li>
    <li><tt>Domain = Type</tt></li>
    <li><tt>Type   = constant()</tt>
           <br/><tt> | integer()</tt>
           <br/><tt> | c_octet_string()</tt>
           <br/><tt> | octet_string()</tt>
           <br/><tt> | multivalue()</tt>
           <br/><tt> | composite()</tt>
           <br/><tt> | polymorphic()</tt></li>
    <li><tt>Error  = int()</tt></li>
  </ul>
</p>

<p>Standard Parameter declaration.</p>

<dl>
  <dt>Name: </dt><dd>Name of the parameter.</dd>
  <dt>Domain: </dt><dd>Domain of the parameter.  Defined by means of the
    base syntax (<b>base_syntax.hrl</b>).
  </dd>
  <dt>Error: </dt><dd>Error code associated to the parameter.</dd>
</dl>


<h3><a name="tlv">tlv</a></h3>

<p><tt>-record(tlv, 
       {name, tag, domain, reserved, mandatory, multiple, default, error})</tt>
  <ul>
    <li><tt>Name      = atom()</tt></li>
    <li><tt>Tag       = int()</tt></li>
    <li><tt>Domain    = Type</tt></li>
    <li><tt>Type   = constant()</tt>
           <br/><tt> | integer()</tt>
           <br/><tt> | c_octet_string()</tt>
           <br/><tt> | octet_string()</tt>
           <br/><tt> | multivalue()</tt>
           <br/><tt> | composite()</tt>
           <br/><tt> | polymorphic()</tt></li>
    <li><tt>Reserved  = Type</tt></li>
    <li><tt>Mandatory = bool()</tt></li>
    <li><tt>Multiple  = bool()</tt></li>
    <li><tt>Default   = term()</tt></li>
    <li><tt>Error  = int()</tt></li>
  </ul>
</p>

<p>Tagged Length Value Parameter declaration.</p>

<dl>
  <dt>Name: </dt><dd>Name of the parameter.</dd>
  <dt>Tag: </dt><dd>Identifier of the TLV.</dd>
  <dt>Domain: </dt><dd>Domain of the parameter.  Defined by means of the
    base syntax (<b>base_syntax.hrl</b>).
  </dd>
  <dt>Reserved: </dt><dd>Set of reserved values for the parameter.  Defined by
    means of the base syntax (<b>base_syntax.hrl</b>).
  </dd>
  <dt>Mandatory: </dt><dd>Boolean.   <tt>true</tt> if the TLV is mandatory.
  </dd>
  <dt>Multiple: </dt><dd>Boolean.  <tt>true</tt> if the TLV can be encoded 
    multiple times.
  </dd>
  <dt>Default: </dt><dd>Default value for the parameter.  If the 
    encoding (or decoding) operation fails the default value should be used
    (if provided).
  </dd>
  <dt>Error: </dt><dd>Error code associated to the parameter.</dd>
</dl>


<h3>Domains and Datatypes</h3>

<p>To see how these concepts are used along this SMPP implementation, 
consider the <tt>addr_ton</tt> field.</p>

<p>Its <b>datatype</b> is a 1 octet integer: <tt>?INTEGER(1)</tt>.</p>

<p>Its <b>domain</b> is the set of all possible TON Values: 
<tt>?BOUND_INTEGER(1, 6)</tt>.</p>


<h2><a name="parammacros">Param Syntax Macros</a></h2>

<p>Macros based on record param-types definitions.</p>

<pre>
-define(STANDARD(Name, Domain, Error), 
        #standard{name = Name, domain = Domain, error = Error}).
-define(TLV(Name, Tag, Domain, Reserved, Mandatory, Multiple, Default, Error), 
        #tlv{name      = Name,
             tag       = Tag, 
             domain    = Domain,
             reserved  = Reserved, 
             mandatory = Mandatory,
             multiple  = Multiple,
             default   = Default, 
             error     = Error}).
</pre>

<p>Simplified TLV Macros for Readability, some options are implicitly assigned
here.  SMPP PDU TLV definitions are more readable using these macros.</p>

<pre>
-define(MANDATORY_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, true, false, Default, Error)).
-define(OPTIONAL_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, false, false, Default, Error)).
-define(MULTIPLE_MANDATORY_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, true, true, Default, Error)).
-define(MULTIPLE_OPTIONAL_TLV(Name, Tag, Domain, Reserved, Default, Error), 
        ?TLV(Name, Tag, Domain, Reserved, false, true, Default, Error)).
</pre>


<h2><a name="pdu">PDU Syntax</a></h2>

<p>This syntax extends the <i>param syntax</i> and gives support to PDU
defintions.</p>

<p>The following types are defined as records on the pdu syntax:</p>

<ol>
  <li><a href="#pdu">pdu</a></li>
</ol>


<h3><a name="pdu">pdu</a></h3>

<p><tt>-record(pdu, {stds_types, tlvs_types})</tt>
  <ul>
    <li><tt>StdsTypes = [standard()]</tt></li>
    <li><tt>TlvsTypes = [tlv()]</tt></li>
  </ul>
</p>

<p>PDU definitions.</p>

<dl>
  <dt>StdsTypes: </dt><dd>List with the types of the standard parameters.
    There is one descriptor per standard parameter on the PDU.  This list
    must have the same exact order than the one defined on the SMPP protocol
    specification.
  </dd>
  <dt>TlvsTypes: </dt><dd>List with the types of every permitted TLV of the
    PDU.  The SMPP protocol specification does not establish any kind of
    ordering for the TLV parameters.  The order on this list might only be
    relevant from an efficiency point of view, refer to the 
    <a href="pdu_syntax.html#pack-3">packing</a>/
    <a href="pdu_syntax.html#unpack-3">unpacking</a> functions 
    implementation on <a href="pdu_syntax.html">pdu_syntax.erl</a>.
  </dd>
</dl>


<h2><a name="pdumacros">PDU Syntax Macros</a></h2>

<p>Macros based on PDU record definition.</p>

<pre>
-define(PDU(StdsTypes, TlvsTypes),
        #pdu{stds_types = StdsTypes, tlvs_types = TlvsTypes}).
</pre>


<h2><a name="behaviours">Behaviours</a></h2>

<p>A generic ESME (External Short Message Entity) behaviour is implemented in 
OSERL.  Behaviours are formalizations of "design patters" which can be used to 
program certain common problems, an ESME in this particular case.  The generic 
ESME behaviour was built on top of a generic session behaviour, having again 
an underlying generic connection behaviour.</p>

<img src="img/behaviours.png" 
     alt="behaviours" 
     border="0" 
     width="600" 
     height="180"/>

<p>The schema depicted on the previous figure shows how the ESME behaviour
is acting as the callback module for the session behaviour, which in turn acts 
as the callback module for the generic connection.</p>

<p>The session receives binary data from the connection through several 
callbacks and unpacks SMPP PDUs therein included.  Some operation PDUs are 
automatically responded and managed by the session behaviour but others, like 
an <i>outbind</i> or <i>deliver_sm</i> PDU, must be forwarded to the upper 
ESME behaviour to let it decide what to do.  The ESME behaviour knows how to 
handle things like an <i>outbind</i> request, but under certain operations, 
such us <i>deliver_sm</i> requests, the callback module implementing the ESME 
behaviour must take care of the work (actions associated to a delivery request 
depends on the particular service provided by the ESME being implemented).</p>

<p>SMS Developers don't need to care about sessions or connections, they will 
just need to implement those exported callbacks of the ESME behaviour relevant
to the particular service they want to develop.  The interface offered by the 
ESME behaviour is shown <a href="gen_esme.html">here</a>.</p>

<p>Leaving a callback unimplemented causes the generic ESME behaviour to 
perform the default action (usually by simply ignoring the callback).  Every 
callback is guaranteed to be correct, never a malformed or unexpected PDU could
trigger a callback.</p>

<p>Due to these behaviours, OSERL handles transparently many aspects of the 
SMPP protocol, saving lots of work to developers by</p>

<ul>
  <li>Automatically handling PDU sequencing. Assigns monotonically 
    increasing sequence numbers and matches requests with their corresponding 
    responses in an asynchronous manner.
  </li>
  <li>OSERL handles automatically all timers defined by the SMPP protocol 
    specification version 5.0: session init timer, enquire link timer, 
    inactivity timer and response timer.  On a timer expiration, the action 
    recommended on the protocol specification is triggered.
  </li>
  <li>Handles every operation failure, including when the PDU is unrecognized 
	or malformed, invalid field length, PDU data is unexpected and deemed 
	invalid, and the PDU is not allowed in the current state.

 	<p>Upon failure the appropriate response is automatically issued.  Even 
	errors associated to individual parameters of the PDUs are detected, and
	reported using the corresponding error code.</p>

    <p>Every error code in the protocol specification was implemented.</p>
  </li>
  <li>Detects connection failures and provides automatic recovery mechanisms,
	restoring dropped sessions.
  </li>
  <li>Controls congestion using the <tt>congestion_state</tt> field.</li>
  <li>Every forward and backwards compatibility guidelines were adopted.</li>
  <li>Supports every operation and every field of the SMPP protocol 
	version 5.0.
  </li>
</ul>


<h2><a name="pics">PICS Proforma</a></h2>

Find OSERL's PICS proforma in openoffice format 
<a href="oserl_pics.sxw">here</a>.


<h2><a name="changes">Changes</a></h2>

<h3><a name="changes0_1-0_2">Changes 0.1 -&gt; 0.2</a></h3>

<ul>
  <li>Default values of standard parameters were included in the parameter
    descriptor (just like in TLVs).  Lists of PDUs default values do no longer
    exist.<br/>
    <br/>
    Refer to <a href="../include/smpp_param.hrl">smpp_param.hrl</a> if you 
    want to change the default value of any parameter.
  </li>
  <li>Trailing <tt>NULL_CHARACTERs</tt> in C-Octet Strings are transparently 
    handled by encoding/decoding functions.  Application layer does not handle 
    terminating NULLs any more.
  </li>
  <li>Absolute and relative time formats are now pure C-Octet Strings (Not 
    records).  <tt>time</tt> record removed.  (Refer to 
    <a href="base_syntax.html">base_syntax.erl</a>, 
    <a href="../include/base_syntax.hrl">base_syntax.hrl</a> and 
    <a href="../include/smpp_base.hrl">smpp_base.hrl</a> for further details).
  </li>
  <li><a href="gen_esme.html">gen_esme</a> callback interface redefined.</li>
</ul>

<p>How these changes affected individual files is described 
<a href="changes.html">here</a>.</p>


<h2><a name="todo">TODO</a></h2>

<ul>
  <li>Version 0.2
  <ol>
    <li>Don't like current PDU packing/unpacking mechanism using the 
      <tt>pdu_type/1</tt> function.

      <p>Consider creating a pack/unpack function for each PDU type.  Call the
      appropriate pack/unpack function by means of the <tt>command_id</tt> and
      remove <tt>pdu_type/1</tt> function.</p>
    </li>
    <li>Try to put the <tt>command_id</tt> back into the PDU descriptor in an
      efficient manner.
    </li>
  </ol>
  </li>
  <li>Version 1.0
    <ol>
      <li>Implement a gen_mc_session behavior.</li>
      <li>Implement a gen_mc behavior.</li>
    </ol>
  </li>
  <li>Version 2.0
    <ol>
      <li>Implement a gen_re behavior.</li>
    </ol>
  </li>
</ul>


<h2><a name="references">References</a></h2>

<dl>
  <dt>[SMPP 5.0]</dt><dd>Short Message Peer-to-Peer Protocol Specification.
    Version 5.0. SMS Forum.
  </dd>
</dl>
